Directory structure:
â””â”€â”€ src/
    â”œâ”€â”€ auction/
    â”‚   â”œâ”€â”€ BeraAuctionHouse.sol
    â”‚   â””â”€â”€ interfaces/
    â”‚       â”œâ”€â”€ IBeraAuctionHouse.sol
    â”‚       â””â”€â”€ IWETH.sol
    â”œâ”€â”€ registrar/
    â”‚   â”œâ”€â”€ Registrar.sol
    â”‚   â”œâ”€â”€ ReverseRegistrar.sol
    â”‚   â”œâ”€â”€ interfaces/
    â”‚   â”‚   â”œâ”€â”€ IPriceOracle.sol
    â”‚   â”‚   â”œâ”€â”€ IReservedRegistry.sol
    â”‚   â”‚   â””â”€â”€ IReverseRegistrar.sol
    â”‚   â””â”€â”€ types/
    â”‚       â”œâ”€â”€ BaseRegistrar.sol
    â”‚       â”œâ”€â”€ Controllable.sol
    â”‚       â”œâ”€â”€ PriceOracle.sol
    â”‚       â”œâ”€â”€ ReservedRegistry.sol
    â”‚       â”œâ”€â”€ ReverseClaimer.sol
    â”‚       â””â”€â”€ bArtioPriceOracle.sol
    â”œâ”€â”€ registry/
    â”‚   â”œâ”€â”€ Registry.sol
    â”‚   â””â”€â”€ interfaces/
    â”‚       â””â”€â”€ BNS.sol
    â”œâ”€â”€ resolver/
    â”‚   â”œâ”€â”€ Resolver.sol
    â”‚   â”œâ”€â”€ UniversalResolver.sol
    â”‚   â”œâ”€â”€ interfaces/
    â”‚   â”‚   â”œâ”€â”€ IABIResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IAddrResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IAddressResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IContentHashResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IExtendedResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IInterfaceResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IMulticallable.sol
    â”‚   â”‚   â”œâ”€â”€ INameResolver.sol
    â”‚   â”‚   â”œâ”€â”€ IPubkeyResolver.sol
    â”‚   â”‚   â”œâ”€â”€ ITextResolver.sol
    â”‚   â”‚   â””â”€â”€ IVersionableResolver.sol
    â”‚   â”œâ”€â”€ libraries/
    â”‚   â”‚   â”œâ”€â”€ BytesUtils.sol
    â”‚   â”‚   â”œâ”€â”€ HexUtils.sol
    â”‚   â”‚   â”œâ”€â”€ LowLevelCallUtils.sol
    â”‚   â”‚   â””â”€â”€ NameEncoder.sol
    â”‚   â”œâ”€â”€ profiles/
    â”‚   â”‚   â”œâ”€â”€ ABIResolver.sol
    â”‚   â”‚   â”œâ”€â”€ AddrResolver.sol
    â”‚   â”‚   â”œâ”€â”€ ContentHashResolver.sol
    â”‚   â”‚   â”œâ”€â”€ ExtendedResolver.sol
    â”‚   â”‚   â”œâ”€â”€ InterfaceResolver.sol
    â”‚   â”‚   â”œâ”€â”€ NameResolver.sol
    â”‚   â”‚   â”œâ”€â”€ PubkeyResolver.sol
    â”‚   â”‚   â””â”€â”€ TextResolver.sol
    â”‚   â””â”€â”€ types/
    â”‚       â”œâ”€â”€ Multicallable.sol
    â”‚       â””â”€â”€ ResolverBase.sol
    â””â”€â”€ utils/
        â”œâ”€â”€ Constants.sol
        â””â”€â”€ StringUtils.sol

================================================
File: src/auction/BeraAuctionHouse.sol
================================================
// SPDX-License-Identifier: GPL-3.0

/// @title The Bera names auction house

// LICENSE
// BeraAuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:
// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol
//
// BeraAuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.
// With modifications by Beranames.
pragma solidity ^0.8.13;

import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {BaseRegistrar} from "src/registrar/types/BaseRegistrar.sol";

import {IWETH} from "src/auction/interfaces/IWETH.sol";

import {IBeraAuctionHouse} from "src/auction/interfaces/IBeraAuctionHouse.sol";

import {BeraDefaultResolver} from "src/resolver/Resolver.sol";

contract BeraAuctionHouse is IBeraAuctionHouse, Pausable, ReentrancyGuard, Ownable {
    /// @notice A hard-coded cap on time buffer to prevent accidental auction disabling if set with a very high value.
    uint56 public constant MAX_TIME_BUFFER = 1 days;

    /// @notice The Registrar Controller that the auction uses to mint the names
    BaseRegistrar public immutable base;

    /// @notice The resolver that the auction uses to resolve the names
    BeraDefaultResolver public immutable resolver;

    /// @notice The address of the WETH contract
    IWETH public immutable weth;

    /// @notice The auctionDuration of a single auction
    uint256 public immutable auctionDuration;
    uint256 public immutable registrationDuration;

    /// @notice the maximum number of auctions count to prevent excessive gas usage.
    uint256 public maxAuctionCount;

    /// @notice The minimum price accepted in an auction
    uint192 public reservePrice;

    /// @notice The minimum amount of time left in an auction after a new bid is created
    uint56 public timeBuffer;

    /// @notice The minimum percentage difference between the last bid amount and the current bid
    uint8 public minBidIncrementPercentage;

    /// @notice The active auction
    IBeraAuctionHouse.Auction public auctionStorage;

    /// @notice Past auction settlements
    mapping(uint256 => SettlementState) settlementHistory;

    /// @notice The address that will receive funds after closing the auction
    address public paymentReceiver;

    /// Constructor ------------------------------------------------------

    /// @notice Constructor for the auction house
    /// @param base_ The base registrar contract
    /// @param resolver_ The resolver contract
    /// @param weth_ The WETH contract
    /// @param auctionDuration_ The duration of the auction
    /// @param registrationDuration_ The duration of the registration
    /// @param reservePrice_ The reserve price of the auction
    /// @param timeBuffer_ The time buffer of the auction
    /// @param minBidIncrementPercentage_ The minimum bid increment percentage of the auction
    /// @param paymentReceiver_ The address that will receive funds after closing the auction
    constructor(
        BaseRegistrar base_,
        BeraDefaultResolver resolver_,
        IWETH weth_,
        uint256 auctionDuration_,
        uint256 registrationDuration_,
        uint192 reservePrice_,
        uint56 timeBuffer_,
        uint8 minBidIncrementPercentage_,
        address paymentReceiver_
    ) Ownable(msg.sender) {
        base = base_;
        resolver = resolver_;
        weth = weth_;
        auctionDuration = auctionDuration_;
        registrationDuration = registrationDuration_;
        paymentReceiver = paymentReceiver_;
        maxAuctionCount = 25;

        _pause();

        if (reservePrice_ == 0) revert InvalidReservePrice();
        if (minBidIncrementPercentage_ == 0) revert MinBidIncrementPercentageIsZero();
        if (timeBuffer_ > MAX_TIME_BUFFER) {
            revert TimeBufferTooLarge(timeBuffer_);
        }

        reservePrice = reservePrice_;
        timeBuffer = timeBuffer_;
        minBidIncrementPercentage = minBidIncrementPercentage_;
    }

    /**
     * @notice Settle the current auction, mint a new name, and put it up for auction.
     */
    function settleCurrentAndCreateNewAuction(string memory label_) external override whenNotPaused onlyOwner {
        _settleAuction();
        _createAuction(label_);
    }

    /**
     * @notice Settle the current auction.
     * @dev This function can only be called when the contract is paused.
     */
    function settleAuction() external override whenPaused onlyOwner nonReentrant {
        _settleAuction();
    }

    function setMaxAuctionCount(uint256 _maxAuctionCount) external whenNotPaused onlyOwner {
        if (_maxAuctionCount == 0) revert MaxAuctionCountIsZero();

        maxAuctionCount = _maxAuctionCount;

        emit MaxAuctionCountUpdated(maxAuctionCount);
    }

    /**
     * @notice Create a bid for a token, with a given amount.
     * @dev This contract only accepts payment in ETH.
     */
    function createBid(uint256 tokenId) external payable override whenNotPaused nonReentrant {
        IBeraAuctionHouse.Auction memory _auction = auctionStorage;

        (uint192 _reservePrice, uint56 _timeBuffer, uint8 _minBidIncrementPercentage) =
            (reservePrice, timeBuffer, minBidIncrementPercentage);

        if (_auction.tokenId != tokenId) {
            revert TokenNotForUpAuction(tokenId);
        }

        if (block.timestamp >= _auction.endTime) {
            revert AuctionExpired();
        }

        if (msg.value < _reservePrice) {
            revert MustSendAtLeastReservePrice();
        }

        if (msg.value < _auction.amount + ((_auction.amount * _minBidIncrementPercentage) / 100)) {
            revert MustSendMoreThanLastBidByMinBidIncrementPercentageAmount();
        }
        auctionStorage.amount = msg.value;
        auctionStorage.bidder = payable(msg.sender);

        // Extend the auction if the bid was received within `timeBuffer` of the auction end time
        bool extended = _auction.endTime - block.timestamp < _timeBuffer;

        emit AuctionBid(_auction.tokenId, msg.sender, msg.value, extended);

        if (extended) {
            auctionStorage.endTime = _auction.endTime = uint40(block.timestamp + _timeBuffer);
            emit AuctionExtended(_auction.tokenId, _auction.endTime);
        }

        address payable lastBidder = _auction.bidder;

        // Refund the last bidder, if applicable
        if (lastBidder != address(0)) {
            _safeTransferETHWithFallback(lastBidder, _auction.amount);
        }
    }

    /**
     * @notice Get the current auction.
     */
    function auction() external view returns (AuctionView memory) {
        return AuctionView({
            tokenId: auctionStorage.tokenId,
            amount: auctionStorage.amount,
            startTime: auctionStorage.startTime,
            endTime: auctionStorage.endTime,
            bidder: auctionStorage.bidder,
            settled: auctionStorage.settled
        });
    }

    /**
     * @notice Pause the auction house.
     * @dev This function can only be called by the owner when the
     * contract is unpaused. While no new auctions can be started when paused,
     * anyone can settle an ongoing auction.
     */
    function pause() external override onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the auction house.
     * @dev This function can only be called by the owner when the
     * contract is paused. If required, this function will start a new auction.
     */
    function unpause(string memory label_) external override onlyOwner {
        _unpause();

        if (auctionStorage.startTime == 0 || auctionStorage.settled) {
            _createAuction(label_);
        }
    }

    /**
     * @notice Set the auction time buffer.
     * @dev Only callable by the owner.
     */
    function setTimeBuffer(uint56 _timeBuffer) external override onlyOwner {
        if (_timeBuffer > MAX_TIME_BUFFER) {
            revert TimeBufferTooLarge(_timeBuffer);
        }

        timeBuffer = _timeBuffer;

        emit AuctionTimeBufferUpdated(_timeBuffer);
    }

    /**
     * @notice Set the auction reserve price.
     * @dev Only callable by the owner.
     */
    function setReservePrice(uint192 _reservePrice) external override onlyOwner {
        if (_reservePrice == 0) {
            revert InvalidReservePrice();
        }
        reservePrice = _reservePrice;

        emit AuctionReservePriceUpdated(_reservePrice);
    }

    /**
     * @notice Set the auction minimum bid increment percentage.
     * @dev Only callable by the owner.
     */
    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {
        if (_minBidIncrementPercentage == 0) {
            revert MinBidIncrementPercentageIsZero();
        }

        minBidIncrementPercentage = _minBidIncrementPercentage;

        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);
    }

    /// @notice Allows the `owner` to set the reverse registrar contract.
    ///
    /// @dev Emits `PaymentReceiverUpdated` after setting the `paymentReceiver` address.
    ///
    /// @param paymentReceiver_ The new payment receiver address.
    function setPaymentReceiver(address paymentReceiver_) external onlyOwner {
        if (paymentReceiver_ == address(0)) revert InvalidPaymentReceiver();
        paymentReceiver = paymentReceiver_;
        emit PaymentReceiverUpdated(paymentReceiver_);
    }

    /**
     * @notice Create an auction.
     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.
     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,
     * catch the revert and pause this contract.
     */
    function _createAuction(string memory label_) internal {
        uint256 id = uint256(keccak256(abi.encodePacked(label_)));
        try base.registerWithRecord(id, address(this), registrationDuration, address(resolver), 0) returns (uint256) {
            uint40 startTime = uint40(block.timestamp);
            uint40 endTime = startTime + uint40(auctionDuration);

            auctionStorage = Auction({
                tokenId: id,
                amount: 0,
                startTime: startTime,
                endTime: endTime,
                bidder: payable(0),
                settled: false
            });

            emit AuctionCreated(id, startTime, endTime);
        } catch Error(string memory reason) {
            _pause();
            emit AuctionCreationError(reason);
        }
    }

    /**
     * @notice Settle an auction, finalizing the bid and paying out to the owner.
     * @dev If there are no bids, the tokenId is burned.
     */
    function _settleAuction() internal {
        if (base.balanceOf(address(this)) == 0) revert NoAuctions();

        IBeraAuctionHouse.Auction memory _auction = auctionStorage;

        if (_auction.startTime == 0) {
            revert AuctionNotBegun();
        }
        if (_auction.settled) {
            revert AuctionAlreadySettled();
        }
        if (block.timestamp < _auction.endTime) {
            revert AuctionNotCompleted();
        }

        auctionStorage.settled = true;

        if (_auction.bidder == address(0)) {
            base.transferFrom(address(this), address(0xdead), _auction.tokenId);
        } else {
            base.transferFrom(address(this), _auction.bidder, _auction.tokenId);
        }

        if (_auction.amount > 0 && paymentReceiver != address(0)) {
            _safeTransferETHWithFallback(paymentReceiver, _auction.amount);
        }

        SettlementState storage settlementState = settlementHistory[_auction.tokenId];
        settlementState.blockTimestamp = uint32(block.timestamp);
        settlementState.amount = ethPriceToUint64(_auction.amount);
        settlementState.winner = _auction.bidder;

        emit AuctionSettled(_auction.tokenId, _auction.bidder, _auction.amount);
    }

    /**
     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.
     */
    function _safeTransferETHWithFallback(address to, uint256 amount) internal {
        if (!_safeTransferETH(to, amount)) {
            weth.deposit{value: amount}();
            weth.transfer(to, amount);
        }
    }

    /**
     * @notice Transfer ETH and return the success status.
     * @dev This function only forwards 30,000 gas to the callee.
     */
    function _safeTransferETH(address to, uint256 value) internal returns (bool) {
        bool success;
        assembly {
            success := call(30000, to, value, 0, 0, 0, 0)
        }
        return success;
    }

    /**
     * @notice Get past auction settlements.
     * @dev Returns up to `auctionCount` settlements in reverse order, meaning settlements[0] will be the most recent auction price.
     * Includes auctions with no bids (blockTimestamp will be > 1)
     * @param auctionCount The number of price observations to get.
     * @return settlements An array of type `Settlement`, where each Settlement includes a timestamp,
     * the tokenId of that auction, the winning bid amount, and the winner's address.
     */
    function getSettlements(uint256 auctionCount) external view returns (Settlement[] memory settlements) {
        if (auctionCount > maxAuctionCount) revert MaxAuctionCountExceeded(auctionCount);

        uint256 latestTokenId = auctionStorage.tokenId;
        if (latestTokenId == 0) revert NoAuctions();

        if (!auctionStorage.settled && latestTokenId > 0) {
            latestTokenId -= 1;
        }

        // First pass: Count valid settlements
        uint256 validCount = 0;
        for (uint256 id = latestTokenId; validCount < auctionCount; --id) {
            SettlementState memory settlementState = settlementHistory[id];
            if (
                settlementState.blockTimestamp > 0 && settlementState.amount > 0 && settlementState.winner != address(0)
            ) {
                validCount++;
            }
            if (id == 0) break;
        }

        // Allocate array with exact size needed
        settlements = new Settlement[](validCount);

        // Second pass: Populate array
        uint256 index = 0;
        for (uint256 id = latestTokenId; index < validCount; --id) {
            SettlementState memory settlementState = settlementHistory[id];
            if (
                settlementState.blockTimestamp > 0 && settlementState.amount > 0 && settlementState.winner != address(0)
            ) {
                settlements[index] = Settlement({
                    blockTimestamp: settlementState.blockTimestamp,
                    amount: uint64PriceToUint256(settlementState.amount),
                    winner: settlementState.winner,
                    tokenId: id
                });
                index++;
            }
            if (id == 0) break;
        }
    }

    /**
     * @notice Get past auction prices.
     * @dev Returns prices in reverse order, meaning prices[0] will be the most recent auction price.
     * Skips auctions where there was no winner, i.e. no bids.
     * Reverts if getting a empty data for an auction that happened, e.g. historic data not filled
     * Reverts if there's not enough auction data, i.e. reached token id 0
     * @param auctionCount The number of price observations to get.
     * @return prices An array of uint256 prices.
     */
    function getPrices(uint256 auctionCount) external view returns (uint256[] memory prices) {
        uint256 latestTokenId = auctionStorage.tokenId;
        if (latestTokenId == 0) revert NoAuctions();

        if (!auctionStorage.settled && latestTokenId > 0) {
            latestTokenId -= 1;
        }

        prices = new uint256[](auctionCount);
        uint256 actualCount = 0;

        SettlementState memory settlementState;
        for (uint256 id = latestTokenId; id > 0 && actualCount < auctionCount; --id) {
            settlementState = settlementHistory[id];

            // Skip auctions with no bids
            if (
                settlementState.blockTimestamp == 0 || settlementState.winner == address(0)
                    || settlementState.amount == 0
            ) {
                continue;
            }

            prices[actualCount] = uint64PriceToUint256(settlementState.amount);
            ++actualCount;
        }

        if (auctionCount != actualCount) {
            revert NotEnoughHistory();
        }
    }

    /**
     * @notice Get all past auction settlements starting at `startId` and settled before or at `endTimestamp`.
     * @param startId the first tokenId to get prices for.
     * @param endTimestamp the latest timestamp for auctions
     * @return settlements An array of type `Settlement`, where each Settlement includes a timestamp,
     * the tokenId of that auction, the winning bid amount, and the winner's address.
     */
    function getSettlementsFromIdtoTimestamp(uint256 startId, uint256 endTimestamp)
        public
        view
        returns (Settlement[] memory settlements)
    {
        if (startId > maxAuctionCount) revert MaxAuctionCountExceeded(startId);

        uint256 maxId = auctionStorage.tokenId;
        if (startId > maxId) revert StartIdTooLarge(startId);

        // First pass: Count valid settlements
        uint256 validCount = 0;
        for (uint256 id = startId; id <= maxId; ++id) {
            SettlementState memory settlementState = settlementHistory[id];

            if (id == maxId && settlementState.blockTimestamp <= 1 && settlementState.winner == address(0)) {
                continue;
            }

            if (settlementState.blockTimestamp > endTimestamp) break;
            validCount++;
        }

        // Allocate array with exact size needed
        settlements = new Settlement[](validCount);

        // Second pass: Populate array
        uint256 index = 0;
        for (uint256 id = startId; id <= maxId && index < validCount; ++id) {
            SettlementState memory settlementState = settlementHistory[id];

            if (id == maxId && settlementState.blockTimestamp <= 1 && settlementState.winner == address(0)) {
                continue;
            }

            if (settlementState.blockTimestamp > endTimestamp) break;

            settlements[index] = Settlement({
                blockTimestamp: settlementState.blockTimestamp,
                amount: uint64PriceToUint256(settlementState.amount),
                winner: settlementState.winner,
                tokenId: id
            });
            index++;
        }
    }

    /**
     * @notice Get a range of past auction settlements.
     * @dev Returns prices in chronological order, as opposed to `getSettlements(count)` which returns prices in reverse order.
     * Includes auctions with no bids (blockTimestamp will be > 1)
     * @param startId the first tokenId to get prices for.
     * @param endId end tokenId (up to, but not including).
     * @return settlements An array of type `Settlement`, where each Settlement includes a timestamp,
     * the tokenId of that auction, the winning bid amount, and the winner's address.
     */
    function getSettlements(uint256 startId, uint256 endId) external view returns (Settlement[] memory settlements) {
        if (startId > maxAuctionCount) revert MaxAuctionCountExceeded(startId);
        if (startId > endId || startId == 0 || endId == 0) revert InvalidRange();

        // First pass: Count valid settlements
        uint256 validCount = 0;
        for (uint256 id = startId; id < endId; ++id) {
            SettlementState memory settlementState = settlementHistory[id];
            if (
                settlementState.blockTimestamp > 0 && settlementState.amount > 0 && settlementState.winner != address(0)
            ) {
                validCount++;
            }
        }

        // Allocate array with exact size needed
        settlements = new Settlement[](validCount);

        // Second pass: Populate array
        uint256 index = 0;
        for (uint256 id = startId; id < endId; ++id) {
            SettlementState memory settlementState = settlementHistory[id];
            if (
                settlementState.blockTimestamp > 0 && settlementState.amount > 0 && settlementState.winner != address(0)
            ) {
                settlements[index] = Settlement({
                    blockTimestamp: settlementState.blockTimestamp,
                    amount: uint64PriceToUint256(settlementState.amount),
                    winner: settlementState.winner,
                    tokenId: id
                });
                index++;
            }
        }
    }

    /**
     * @dev Convert an ETH price of 256 bits with 18 decimals, to 64 bits with 10 decimals.
     * Max supported value is 1844674407.3709551615 ETH.
     */
    function ethPriceToUint64(uint256 ethPrice) internal pure returns (uint64) {
        uint256 scaled = ethPrice / 1e8;
        if (scaled > type(uint64).max) revert PriceExceedsUint64Range(ethPrice);

        return uint64(scaled);
    }

    /**
     * @dev Convert a 64 bit 10 decimal price to a 256 bit 18 decimal price.
     */
    function uint64PriceToUint256(uint64 price) internal pure returns (uint256) {
        return uint256(price) * 1e8;
    }
}


================================================
File: src/auction/interfaces/IBeraAuctionHouse.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.19;

/// @title Interface for Bera Names Auction House
interface IBeraAuctionHouse {
    /// Errors -----------------------------------------------------------
    /// @notice Thrown when the token is not up for auction.
    /// @param tokenId The token ID that is not up for auction.
    error TokenNotForUpAuction(uint256 tokenId);

    /// @notice Thrown when the auction has expired.
    error AuctionExpired();

    /// @notice Thrown when the bid is less than the reserve price.
    error MustSendAtLeastReservePrice();

    /// @notice Thrown when the bid is less than the minimum bid increment percentage amount.
    error MustSendMoreThanLastBidByMinBidIncrementPercentageAmount();

    /// @notice Thrown when the time buffer is too large.
    error TimeBufferTooLarge(uint256 timeBuffer);

    /// @notice Thrown when the min bid increment percentage is zero.
    error MinBidIncrementPercentageIsZero();

    /// @notice Thrown when the auction has not begun.
    error AuctionNotBegun();

    /// @notice Thrown when the auction has already been settled.
    error AuctionAlreadySettled();

    /// @notice Thrown when the auction has not completed.
    error AuctionNotCompleted();

    /// @notice Thrown when there is missing data.
    error MissingSettlementsData();

    /// @notice Thrown when there is not enough history.
    error NotEnoughHistory();

    /// @notice Thrown when there are no auctions.
    error NoAuctions();

    /// @notice Thrown when the provided range is invalid.
    error InvalidRange();

    /// @notice Thrown when the start ID is too large.
    error StartIdTooLarge(uint256 startId);

    /// @notice Thrown when the payment receiver is being set to address(0).
    error InvalidPaymentReceiver();

    /// @notice Thrown when the reserve price is being set to 0.
    error InvalidReservePrice();

    /// @notice Thrown when the max auction count is being set to 0.
    error MaxAuctionCountIsZero();

    /// @notice Thrown when the max auction count is exceeded.
    error MaxAuctionCountExceeded(uint256 auctionCount);

    /// @notice Thrown when the price exceeds the uint64 range.
    error PriceExceedsUint64Range(uint256 price);

    struct Auction {
        uint256 tokenId;
        uint256 amount;
        uint64 startTime;
        uint64 endTime;
        // The address of the current highest bid
        address payable bidder;
        // Whether or not the auction has been settled
        bool settled;
    }

    /// @dev We use this struct as the return value of the `auction` function, to maintain backwards compatibility.
    /// @param labelHash The labelHash for the name (max X characters)
    /// @param amount The current highest bid amount
    /// @param startTime The auction period start time
    /// @param endTime The auction period end time
    /// @param bidder The address of the current highest bid
    /// @param settled Whether or not the auction has been settled
    struct AuctionView {
        // Slug 1
        uint256 tokenId;
        // Slug 2
        uint256 amount;
        uint64 startTime;
        uint64 endTime;
        // Slug 3
        address payable bidder;
        bool settled;
    }

    /// @param blockTimestamp The block.timestamp when the auction was settled.
    /// @param amount The winning bid amount, with 10 decimal places (reducing accuracy to save bits).
    /// @param winner The address of the auction winner.
    struct SettlementState {
        uint32 blockTimestamp;
        uint64 amount;
        address winner;
    }

    /// @param blockTimestamp The block.timestamp when the auction was settled.
    /// @param amount The winning bid amount, converted from 10 decimal places to 18, for better client UX.
    /// @param winner The address of the auction winner.
    /// @param tokenId ID for the label (label hash).
    struct Settlement {
        uint32 blockTimestamp;
        uint256 amount;
        address winner;
        uint256 tokenId;
    }

    event AuctionCreated(uint256 indexed tokenId, uint256 startTime, uint256 endTime);

    event AuctionBid(uint256 indexed tokenId, address sender, uint256 value, bool extended);

    event AuctionExtended(uint256 indexed tokenId, uint256 endTime);

    event AuctionSettled(uint256 indexed tokenId, address winner, uint256 amount);

    event AuctionTimeBufferUpdated(uint256 timeBuffer);

    event AuctionReservePriceUpdated(uint256 reservePrice);

    event AuctionMinBidIncrementPercentageUpdated(uint256 minBidIncrementPercentage);

    event AuctionCreationError(string reason);

    event MaxAuctionCountUpdated(uint256 maxAuctionCount);

    /// @notice Emitted when the payment receiver is updated.
    ///
    /// @param newPaymentReceiver The address of the new payment receiver.
    event PaymentReceiverUpdated(address newPaymentReceiver);

    function settleAuction() external;

    function settleCurrentAndCreateNewAuction(string memory label_) external;

    function createBid(uint256 tokenId) external payable;

    // Management functions

    function pause() external;
    function unpause(string memory label_) external;

    function setTimeBuffer(uint56 timeBuffer) external;
    function setReservePrice(uint192 reservePrice) external;
    function setMinBidIncrementPercentage(uint8 minBidIncrementPercentage) external;

    function auction() external view returns (AuctionView memory);

    function getSettlements(uint256 auctionCount) external view returns (Settlement[] memory settlements);

    function getPrices(uint256 auctionCount) external view returns (uint256[] memory prices);

    function getSettlements(uint256 startId, uint256 endId) external view returns (Settlement[] memory settlements);

    function getSettlementsFromIdtoTimestamp(uint256 startId, uint256 endTimestamp)
        external
        view
        returns (Settlement[] memory settlements);

    function auctionDuration() external view returns (uint256);
    function registrationDuration() external view returns (uint256);
}


================================================
File: src/auction/interfaces/IWETH.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.6;

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    function transfer(address to, uint256 value) external returns (bool);
}


================================================
File: src/registrar/Registrar.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {BaseRegistrar} from "src/registrar/types/BaseRegistrar.sol";
import {BeraDefaultResolver} from "src/resolver/Resolver.sol";

import {IPriceOracle} from "src/registrar/interfaces/IPriceOracle.sol";
import {IReverseRegistrar} from "src/registrar/interfaces/IReverseRegistrar.sol";
import {IReservedRegistry} from "src/registrar/interfaces/IReservedRegistry.sol";

import {BERA_NODE, GRACE_PERIOD} from "src/utils/Constants.sol";
import {StringUtils} from "src/utils/StringUtils.sol";

/// @title Registrar Controller
contract RegistrarController is Ownable, ReentrancyGuard {
    using StringUtils for string;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /// Errors -----------------------------------------------------------

    /// @notice Thrown when a name is not available.
    /// @param name The name that is not available.
    error NameNotAvailable(string name);

    /// @notice Thrown when a name's duration is not longer than `MIN_REGISTRATION_DURATION`.
    /// @param duration The duration that was too short.
    error DurationTooShort(uint256 duration);

    /// @notice Thrown when the public sale is not live.
    error PublicSaleNotLive();

    /// @notice Thrown when Multicallable resolver data was specified but not resolver address was provided.
    error ResolverRequiredWhenDataSupplied();

    /// @notice Thrown when the payment received is less than the price.
    error InsufficientValue();

    /// @notice Thrown when the payment receiver is being set to address(0).
    error InvalidPaymentReceiver();

    /// @notice Thrown when a signature has already been used.
    error SignatureAlreadyUsed();

    /// @notice Thrown when a refund transfer is unsuccessful.
    error TransferFailed();

    /// @notice Thrown when a name is reserved.
    error NameReserved();

    /// @notice Thrown when a reverse record is being set for another address.
    error CantSetReverseRecordForOthers();

    /// @notice Thrown when a mint limit for a round is reached.
    error MintLimitForRoundReached();

    /// @notice Thrown when someone tries to mint a reserved name but is not authorised
    error NotAuthorisedToMintReservedNames();

    /// @notice Thrown when the name is not reserved but you try to mint via reserved minting flow
    error NameNotReserved();

    /// @notice Thrown when a free mint signature has already been used.
    error FreeMintSignatureAlreadyUsed();

    /// @notice Thrown when the launch time is in the past.
    error LaunchTimeInPast();

    /// @notice Thrown when a reverse record is not allowed for reserved names.
    error ReverseRecordNotAllowedForReservedNames();

    /// @notice Thrown when the signature is invalid.
    error InvalidSignature();

    /// @notice Thrown when the free mint limit is reached.
    error FreeMintLimitReached();

    /// @notice Thrown when the whitelist signer is invalid.
    error InvalidWhitelistSigner();

    /// @notice Thrown when the free whitelist signer is invalid.
    error InvalidFreeWhitelistSigner();

    /// Events -----------------------------------------------------------

    /// @notice Emitted when an ETH payment was processed successfully.
    ///
    /// @param payee Address that sent the ETH.
    /// @param price Value that was paid.
    event ETHPaymentProcessed(address indexed payee, uint256 price);

    /// @notice Emitted when a name was registered.
    ///
    /// @param name The name that was registered.
    /// @param label The hashed label of the name.
    /// @param owner The owner of the name that was registered.
    /// @param expires The date that the registration expires.
    event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint256 expires);

    /// @notice Emitted when a name is registered with a referral.
    ///
    /// @dev two different events to keep compatibility with ENS
    /// @param name The name that was registered
    /// @param label The hashed label of the name
    /// @param owner The owner of the name that was registered
    /// @param referral The address of the referral
    /// @param expires The date that the registration expires
    event NameRegisteredWithReferral(
        string name, bytes32 indexed label, address indexed owner, address indexed referral, uint256 expires
    );

    /// @notice Emitted when a name is renewed.
    ///
    /// @param name The name that was renewed.
    /// @param label The hashed label of the name.
    /// @param expires The date that the renewed name expires.
    event NameRenewed(string name, bytes32 indexed label, uint256 expires);

    /// @notice Emitted when the payment receiver is updated.
    ///
    /// @param newPaymentReceiver The address of the new payment receiver.
    event PaymentReceiverUpdated(address newPaymentReceiver);

    /// @notice Emitted when the price oracle is updated.
    ///
    /// @param newPrices The address of the new price oracle.
    event PriceOracleUpdated(address newPrices);

    /// @notice Emitted when the reverse registrar is updated.
    ///
    /// @param newReverseRegistrar The address of the new reverse registrar.
    event ReverseRegistrarUpdated(address newReverseRegistrar);

    /// @notice Emitted when the launch time is updated.
    ///
    /// @param newLaunchTime The new launch time.
    event LaunchTimeUpdated(uint256 newLaunchTime);

    /// @notice Emitted when reserved names minter is changed
    ///
    /// @param newReservedNameMinterAddress the new address;
    event ReservedNamesMinterChanged(address newReservedNameMinterAddress);

    /// @notice Emitted when whitelist authorizer is changed
    ///
    /// @param newWhitelistAuthorizerAddress the new address;
    event WhitelistAuthorizerChanged(address newWhitelistAuthorizerAddress);

    /// @notice Emitted when free whitelist authorizer is changed
    ///
    /// @param newFreeWhitelistAuthorizerAddress the new address;
    event FreeWhitelistAuthorizerChanged(address newFreeWhitelistAuthorizerAddress);

    /// Datastructures ---------------------------------------------------

    /// @notice The details of a registration request.
    /// @param name The name being registered.
    /// @param owner The address of the owner for the name.
    /// @param duration The duration of the registration in seconds.
    /// @param resolver The address of the resolver to set for this name.
    /// @param data Multicallable data bytes for setting records in the associated resolver upon reigstration.
    /// @param reverseRecord Bool to decide whether to set this name as the "primary" name for the `owner`.
    /// @param referrer The address of the referrer - a zero address indicates no referrer.
    struct RegisterRequest {
        string name;
        address owner;
        uint256 duration;
        address resolver;
        bytes[] data;
        bool reverseRecord;
        address referrer;
    }

    /// @notice The details of a whitelist registration request.
    /// @param registerRequest The `RegisterRequest` struct containing the details for the registration.
    /// @param round_id The ID of the round that the registration is being made in.
    /// @param round_total_mint The total number of mints allowed in the round.
    struct WhitelistRegisterRequest {
        RegisterRequest registerRequest;
        uint256 round_id;
        uint256 round_total_mint;
    }

    /// Storage ----------------------------------------------------------

    /// @notice The implementation of the `BaseRegistrar`.
    BaseRegistrar immutable base;

    /// @notice The implementation of the pricing oracle.
    IPriceOracle public prices;

    /// @notice The implementation of the Reverse Registrar contract.
    IReverseRegistrar public reverseRegistrar;

    /// @notice The implementation of the Reserved Registry contract.
    IReservedRegistry public reservedRegistry;

    /// @notice The node for which this name enables registration. It must match the `rootNode` of `base`.
    bytes32 public immutable rootNode;

    /// @notice The name for which this registration adds subdomains for, i.e. ".bera".
    string public rootName;

    /// @notice The address that will receive ETH funds upon `withdraw()` being called.
    address public paymentReceiver;

    /// @notice The mapping of used signatures.
    mapping(bytes32 => bool) public usedSignatures;

    /// @notice The mapping of used free mints signatures.
    mapping(bytes32 => bool) public usedFreeMintsSignatures;

    /// @notice The mapping of mints count by round by address.
    /// example: 0x123 => { 1st Round => 3 mints, 2nd Round => 1 mint }
    mapping(address => mapping(uint256 => uint256)) public mintsCountByRoundByAddress;

    /// @notice The timestamp of "go-live". Used for setting at-launch pricing premium.
    uint256 public launchTime;

    /// Constants --------------------------------------------------------

    /// @notice The minimum registration duration, specified in seconds.
    uint256 public constant MIN_REGISTRATION_DURATION = 365 days;

    /// @notice The minimum name length.
    uint256 public constant MIN_NAME_LENGTH = 1;

    /// @notice The address of the reserved names minter.
    address private reservedNamesMinter;

    /// @notice The address of the whitelist authorizer.
    address private whitelistAuthorizer;

    /// @notice The address of the free whitelist authorizer.
    address private freeWhitelistAuthorizer;

    /// @notice The mapping of free mints count by address.
    mapping(address => uint8) public freeMintsByAddress;

    /// Modifiers --------------------------------------------------------

    /// @notice Decorator for validating registration requests.
    ///
    /// @dev Validates that:
    ///     1. There is a `resolver` specified` when `data` is set
    ///     2. That the name is `available()`
    ///     3. That the registration `duration` is sufficiently long
    ///
    /// @param request The RegisterRequest that is being validated.
    modifier validRegistration(RegisterRequest calldata request) {
        if (request.data.length > 0 && request.resolver == address(0)) {
            revert ResolverRequiredWhenDataSupplied();
        }
        if (!available(request.name)) {
            revert NameNotAvailable(request.name);
        }
        if (request.duration < MIN_REGISTRATION_DURATION) {
            revert DurationTooShort(request.duration);
        }
        _;
    }

    /// @notice Decorator for validating that the public sale is live.
    modifier publicSaleLive() {
        if (block.timestamp < launchTime) revert PublicSaleNotLive();
        _;
    }

    /// Constructor ------------------------------------------------------

    /// @notice Registrar Controller construction sets all of the requisite external contracts.
    ///
    /// @dev Assigns ownership of this contract's reverse record to the `owner_`.
    ///
    /// @param base_ The base registrar contract.
    /// @param prices_ The pricing oracle contract.
    /// @param reverseRegistrar_ The reverse registrar contract.
    /// @param whitelistSigner_ The whitelist signer contract.
    /// @param freeWhitelistSigner_ The free whitelist signer contract.
    /// @param reservedRegistry_ The reserved registry contract.
    /// @param owner_ The permissioned address initialized as the `owner` in the `Ownable` context.
    /// @param rootNode_ The node for which this registrar manages registrations.
    /// @param rootName_ The name of the root node which this registrar manages.
    /// @param paymentReceiver_ The address that will receive ETH funds upon `withdraw()` being called.
    constructor(
        BaseRegistrar base_,
        IPriceOracle prices_,
        IReverseRegistrar reverseRegistrar_,
        address whitelistSigner_,
        address freeWhitelistSigner_,
        IReservedRegistry reservedRegistry_,
        address owner_,
        bytes32 rootNode_,
        string memory rootName_,
        address paymentReceiver_
    ) Ownable(owner_) {
        base = base_;
        prices = prices_;
        reverseRegistrar = reverseRegistrar_;
        if (whitelistSigner_ == address(0)) revert InvalidWhitelistSigner();
        whitelistAuthorizer = whitelistSigner_;
        if (freeWhitelistSigner_ == address(0)) revert InvalidFreeWhitelistSigner();
        freeWhitelistAuthorizer = freeWhitelistSigner_;
        rootNode = rootNode_;
        rootName = rootName_;
        paymentReceiver = paymentReceiver_;
        reservedRegistry = reservedRegistry_;
        reverseRegistrar.claim(owner_);
    }

    /// Admin Functions ------------------------------------------------

    /// @notice Allows the `owner` to set the pricing oracle contract.
    ///
    /// @dev Emits `PriceOracleUpdated` after setting the `prices` contract.
    ///
    /// @param prices_ The new pricing oracle.
    function setPriceOracle(IPriceOracle prices_) external onlyOwner {
        prices = prices_;
        emit PriceOracleUpdated(address(prices_));
    }

    /// @notice Allows the `owner` to set the reverse registrar contract.
    ///
    /// @dev Emits `ReverseRegistrarUpdated` after setting the `reverseRegistrar` contract.
    ///
    /// @param reverse_ The new reverse registrar contract.
    function setReverseRegistrar(IReverseRegistrar reverse_) external onlyOwner {
        reverseRegistrar = reverse_;
        emit ReverseRegistrarUpdated(address(reverse_));
    }

    /// @notice Allows the `owner` to set the stored `launchTime`.
    ///
    /// @param launchTime_ The new launch time timestamp.
    function setLaunchTime(uint256 launchTime_) external onlyOwner {
        if (launchTime_ < block.timestamp) {
            revert LaunchTimeInPast();
        }

        launchTime = launchTime_;
        emit LaunchTimeUpdated(launchTime_);
    }

    /// @notice Allows the `owner` to set the reverse registrar contract.
    ///
    /// @dev Emits `PaymentReceiverUpdated` after setting the `paymentReceiver` address.
    ///
    /// @param paymentReceiver_ The new payment receiver address.
    function setPaymentReceiver(address paymentReceiver_) external onlyOwner {
        if (paymentReceiver_ == address(0)) revert InvalidPaymentReceiver();
        paymentReceiver = paymentReceiver_;
        emit PaymentReceiverUpdated(paymentReceiver_);
    }

    /// @notice Checks whether the provided `name` is valid. A name is valid if it's longer than 0 chars and not a single emoji (simple or complex).
    /// a => valid
    /// foo => valid
    /// aðŸ’© => valid
    /// ðŸ’©ðŸ’© => valid
    /// ðŸ’© => invalid
    /// ðŸ‘ï¸ => invalid
    /// @param name The name to check the length of.
    ///
    /// @return `true` if the name is valid, else `false`.
    function valid(string memory name) public pure returns (bool) {
        uint256 utfLen = name.utf8Length();
        uint256 strlen = name.strlen();
        return utfLen > 0 && !(strlen == MIN_NAME_LENGTH && utfLen > MIN_NAME_LENGTH);
    }

    /// @notice Checks whether the provided `name` is available.
    ///
    /// @param name The name to check the availability of.
    ///
    /// @return `true` if the name is `valid` and available on the `base` registrar, else `false`.
    function available(string memory name) public view returns (bool) {
        bytes32 label = keccak256(bytes(name));
        return valid(name) && base.isAvailable(uint256(label));
    }

    /// @notice Checks the rent price for a provided `name` and `duration`.
    ///
    /// @param name The name to check the rent price of.
    /// @param duration The time that the name would be rented.
    ///
    /// @return price The `Price` tuple containing the base and premium prices respectively, denominated in wei.
    function rentPrice(string memory name, uint256 duration) public view returns (IPriceOracle.Price memory price) {
        bytes32 label = keccak256(bytes(name));
        price = prices.price(name, _getExpiry(uint256(label)), duration);
    }

    /// @notice Checks the register price for a provided `name` and `duration`.
    ///
    /// @param name The name to check the register price of.
    /// @param duration The time that the name would be registered.
    ///
    /// @return The all-in price for the name registration, denominated in wei.
    function registerPrice(string memory name, uint256 duration) public view returns (uint256) {
        IPriceOracle.Price memory price = rentPrice(name, duration);
        return price.base - price.discount;
    }

    /// @notice Enables a caller to register a name.
    ///
    /// @dev Validates the registration details via the `validRegistration` modifier.
    ///     This `payable` method must receive appropriate `msg.value` to pass `_validatePayment()`.
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    function register(RegisterRequest calldata request) public payable publicSaleLive {
        _validateRegistration(request);
        _register(request);
    }

    /// @notice Allows a whitelisted address to register a name.
    ///
    /// @dev Validates the registration details via the `validRegistration` modifier.
    ///     This `payable` method must receive appropriate `msg.value` to pass `_validatePayment()`.
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    /// @param signature The signature of the whitelisted address.
    function whitelistRegister(WhitelistRegisterRequest calldata request, bytes calldata signature) public payable {
        _validateWhitelist(request, signature);
        _validateRegistration(request.registerRequest);
        _register(request.registerRequest);
    }

    /// @notice Allows a whitelisted address to register a name for free
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    /// @param signature The signature of the whitelisted address.
    function whitelistFreeRegister(RegisterRequest calldata request, bytes calldata signature)
        public
        validRegistration(request)
    {
        _validateFreeWhitelist(request, signature);

        uint256 strlen = request.name.strlen();
        if (strlen < 3) revert NameNotAvailable(request.name);

        _validateRegistration(request);
        _registerRequest(request);
    }

    /// @notice Allows the reserved names minter to register a reserved name.
    ///
    /// @dev Skips the _validateRegistration because it's callable only by reservedNamesMinter
    /// @dev Calls the _registerRequest directly because it's not payable, so we don't need to validate payment
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    function reservedRegister(RegisterRequest calldata request) public validRegistration(request) {
        if (msg.sender != reservedNamesMinter) {
            revert NotAuthorisedToMintReservedNames();
        }
        if (!reservedRegistry.isReservedName(request.name)) revert NameNotReserved();
        if (request.reverseRecord) revert ReverseRecordNotAllowedForReservedNames();

        _registerRequest(request);
    }

    /// @notice Internal helper for registering a name.
    ///
    /// @dev Validates the registration details via the `validRegistration` modifier.
    ///     This `payable` method must receive appropriate `msg.value` to pass `_validatePayment()`.
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    function _register(RegisterRequest calldata request) internal validRegistration(request) {
        uint256 price = registerPrice(request.name, request.duration);

        _validatePayment(price);
        _registerRequest(request);
        _refundExcessEth(price);
    }

    /// @notice Allows a caller to renew a name for a specified duration.
    ///
    /// @dev This `payable` method must receive appropriate `msg.value` to pass `_validatePayment()`.
    ///     The price for renewal never incorporates pricing `premium`. This is because we only expect
    ///     renewal on names that are not expired or are in the grace period. Use the `base` price returned
    ///     by the `rentPrice` tuple to determine the price for calling this method.
    ///
    /// @param name The name that is being renewed.
    /// @param duration The duration to extend the expiry, in seconds.
    function renew(string calldata name, uint256 duration) external payable {
        bytes32 labelhash = keccak256(bytes(name));
        uint256 tokenId = uint256(labelhash);
        uint256 price = registerPrice(name, duration);

        _validatePayment(price);

        uint256 expires = base.renew(tokenId, duration);

        _refundExcessEth(price);

        emit NameRenewed(name, labelhash, expires);
    }

    /// @notice Internal helper for validating ETH payments
    ///
    /// @dev Emits `ETHPaymentProcessed` after validating the payment.
    ///
    /// @param price The expected value.
    function _validatePayment(uint256 price) internal {
        if (msg.value < price) {
            revert InsufficientValue();
        }
        emit ETHPaymentProcessed(msg.sender, price);
    }

    function _validateRegistration(RegisterRequest calldata request) internal view {
        if (reservedRegistry.isReservedName(request.name)) revert NameReserved();
        if (request.owner != msg.sender && request.reverseRecord) revert CantSetReverseRecordForOthers();
    }

    /// @notice Validates the whitelist registration request and signature.
    /// @param request The `WhitelistRegisterRequest` struct containing the details for the registration.
    /// @param signature The signature of the whitelisted address.
    /// @dev Encodes the payload following the WhitelistRegisterRequest struct order. Writes the payload hash to the `usedSignatures` mapping.
    /// @dev Checks if the payload hash has already been used.
    /// @dev Checks if the mint count for the round has not exceeded the total mint limit.
    /// @dev Checks if the signer is the whitelist authorizer.
    function _validateWhitelist(WhitelistRegisterRequest calldata request, bytes calldata signature) internal {
        bytes memory payload = abi.encode(
            request.registerRequest.name,
            request.registerRequest.owner,
            request.registerRequest.duration,
            request.registerRequest.resolver,
            request.registerRequest.data,
            request.registerRequest.reverseRecord,
            request.registerRequest.referrer,
            request.round_id,
            request.round_total_mint
        );
        bytes32 payloadHash = generatePersonalPayloadHash(payload);

        if (usedSignatures[payloadHash]) revert SignatureAlreadyUsed();
        if (mintsCountByRoundByAddress[msg.sender][request.round_id] >= request.round_total_mint) {
            revert MintLimitForRoundReached();
        }

        address signer = getSignerFromSignature(payloadHash, signature);

        if (signer == address(0) || signer != whitelistAuthorizer) revert InvalidSignature();

        usedSignatures[payloadHash] = true;
        mintsCountByRoundByAddress[msg.sender][request.round_id]++;
    }

    /// @notice Validates the free whitelist registration request and signature.
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    /// @param signature The signature of the whitelisted address.
    /// @dev Encodes the payload following the RegisterRequest struct order. Writes the payload hash to the `usedFreeMintsSignatures` mapping.
    /// @dev Checks if the payload hash has already been used.
    /// @dev Checks if the owner has just one free mint.
    function _validateFreeWhitelist(RegisterRequest calldata request, bytes calldata signature) internal {
        bytes memory payload = abi.encode(
            request.name,
            request.owner,
            request.duration,
            request.resolver,
            request.data,
            request.reverseRecord,
            request.referrer
        );
        bytes32 payloadHash = generatePersonalPayloadHash(payload);

        if (usedFreeMintsSignatures[payloadHash]) revert FreeMintSignatureAlreadyUsed();
        if (freeMintsByAddress[msg.sender] != 0) revert FreeMintLimitReached();

        address signer = getSignerFromSignature(payloadHash, signature);

        if (signer == address(0) || signer != freeWhitelistAuthorizer) revert InvalidSignature();

        usedFreeMintsSignatures[payloadHash] = true;
        freeMintsByAddress[msg.sender]++;
    }

    function generatePersonalPayloadHash(bytes memory payload) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(payload)));
    }

    function getSignerFromSignature(bytes32 payloadHash, bytes calldata signature) internal pure returns (address) {
        return ECDSA.recover(payloadHash, signature);
    }

    /// @notice Get the whitelist authorizer.
    /// @return The address of the whitelist authorizer.
    function getWhitelistAuthorizer() public view returns (address) {
        return whitelistAuthorizer;
    }

    /// @notice Get the free whitelist authorizer.
    /// @return The address of the free whitelist authorizer.
    function getFreeWhitelistAuthorizer() public view returns (address) {
        return freeWhitelistAuthorizer;
    }

    /// @notice Get the reserved names minter.
    /// @return The address of the reserved names minter.
    function getReservedNamesMinter() public view returns (address) {
        return reservedNamesMinter;
    }

    /// @notice Helper for deciding whether to include a launch-premium.
    ///
    /// @dev If the token returns a `0` expiry time, it hasn't been registered before. On launch, this will be true for all
    ///     names. Use the `launchTime` to establish a premium price around the actual launch time.
    ///
    /// @param tokenId The ID of the token to check for expiry.
    ///
    /// @return expires Returns the expiry + GRACE_PERIOD for previously registered names, else `launchTime`.
    function _getExpiry(uint256 tokenId) internal view returns (uint256 expires) {
        expires = base.nameExpires(bytes32(tokenId));
        if (expires == 0) {
            return launchTime;
        }
        return expires + GRACE_PERIOD;
    }

    /// @notice Shared registration logic for both `register()` and `whitelistRegister()`.
    ///
    /// @dev Will set records in the specified resolver if the resolver address is non zero and there is `data` in the `request`.
    ///     Will set the reverse record's owner as msg.sender if `reverseRecord` is `true`.
    ///     Emits `NameRegistered` upon successful registration.
    ///
    /// @param request The `RegisterRequest` struct containing the details for the registration.
    function _registerRequest(RegisterRequest calldata request) internal {
        uint256 expires = base.registerWithRecord(
            uint256(keccak256(bytes(request.name))), request.owner, request.duration, request.resolver, 0
        );

        if (request.data.length > 0) {
            _setRecords(request.resolver, keccak256(bytes(request.name)), request.data);
        }

        if (request.reverseRecord) {
            _setReverseRecord(request.name, request.resolver, msg.sender);
        }

        // two different events for ENS compatibility
        emit NameRegistered(request.name, keccak256(bytes(request.name)), request.owner, expires);
        if (request.referrer != address(0)) {
            emit NameRegisteredWithReferral(
                request.name, keccak256(bytes(request.name)), request.owner, request.referrer, expires
            );
        }
    }

    /// @notice Refunds any remaining `msg.value` after processing a registration or renewal given`price`.
    /// @param price The total value to be retained, denominated in wei.
    function _refundExcessEth(uint256 price) internal nonReentrant {
        if (msg.value > price) {
            (bool sent,) = payable(msg.sender).call{value: (msg.value - price)}("");
            if (!sent) revert TransferFailed();
        }
    }

    /// @notice Uses Multicallable to iteratively set records on a specified resolver.
    /// @dev `multicallWithNodeCheck` ensures that each record being set is for the specified `label`.
    /// @param resolverAddress The address of the resolver to set records on.
    /// @param label The keccak256 namehash for the specified name.
    /// @param data  The abi encoded calldata records that will be used in the multicallable resolver.
    function _setRecords(address resolverAddress, bytes32 label, bytes[] calldata data) internal {
        bytes32 nodehash = keccak256(abi.encodePacked(rootNode, label));
        BeraDefaultResolver resolver = BeraDefaultResolver(resolverAddress);
        resolver.multicallWithNodeCheck(nodehash, data);
    }

    /// @notice Sets the reverse record to `owner` for a specified `name` on the specified `resolver.
    /// @param name The specified name.
    /// @param resolver The resolver to set the reverse record on.
    /// @param owner  The owner of the reverse record.
    function _setReverseRecord(string memory name, address resolver, address owner) internal {
        reverseRegistrar.setNameForAddr(msg.sender, owner, resolver, string.concat(name, rootName));
    }

    /// @notice Allows anyone to withdraw the eth accumulated on this contract back to the `paymentReceiver`.
    function withdrawETH() public {
        (bool sent,) = payable(paymentReceiver).call{value: (address(this).balance)}("");
        if (!sent) revert TransferFailed();
    }

    /// @notice Allows the owner to recover ERC20 tokens sent to the contract by mistake.
    function recoverFunds(address _token, address _to, uint256 _amount) external onlyOwner {
        IERC20(_token).safeTransfer(_to, _amount);
    }

    /// @notice Allows the owner to set the reserved names minter.
    /// @param reservedNamesMinter_ The address of the reserved names minter.
    function setReservedNamesMinter(address reservedNamesMinter_) external onlyOwner {
        reservedNamesMinter = reservedNamesMinter_;
        emit ReservedNamesMinterChanged(reservedNamesMinter);
    }

    function setWhitelistAuthorizer(address _whitelistAuthorizer) external onlyOwner {
        whitelistAuthorizer = _whitelistAuthorizer;
        emit WhitelistAuthorizerChanged(_whitelistAuthorizer);
    }

    function setFreeWhitelistAuthorizer(address _freeWhitelistAuthorizer) external onlyOwner {
        freeWhitelistAuthorizer = _freeWhitelistAuthorizer;
        emit FreeWhitelistAuthorizerChanged(_freeWhitelistAuthorizer);
    }
}


================================================
File: src/registrar/ReverseRegistrar.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {BNS} from "src/registry/interfaces/BNS.sol";
import {IReverseRegistrar} from "src/registrar/interfaces/IReverseRegistrar.sol";
import {Controllable} from "src/registrar/types/Controllable.sol";
import {AbstractNameResolver} from "src/resolver/interfaces/INameResolver.sol";

import {ADDR_REVERSE_NODE} from "src/utils/Constants.sol";

contract ReverseRegistrar is Controllable, IReverseRegistrar {
    BNS public immutable registry;
    AbstractNameResolver public defaultResolver;

    event ReverseClaimed(address indexed addr, bytes32 indexed node);
    event DefaultResolverChanged(AbstractNameResolver indexed resolver);

    /**
     * @dev Constructor
     * @param registry_ The address of the BNS registry.
     */
    constructor(BNS registry_) Controllable(msg.sender) {
        if (address(registry_) == address(0)) revert InvalidRegistry();

        registry = registry_;
        // Note: caller needs to assign ownership of the reverse record to the registrar
    }

    modifier authorised(address addr) {
        require(
            addr == msg.sender || controllers[msg.sender] || registry.isApprovedForAll(addr, msg.sender)
                || ownsContract(addr),
            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"
        );
        _;
    }

    function setDefaultResolver(address resolver) public onlyOwner {
        require(address(resolver) != address(0), "ReverseRegistrar: Resolver address must not be 0");
        defaultResolver = AbstractNameResolver(resolver);
        emit DefaultResolverChanged(AbstractNameResolver(resolver));
    }

    /**
     * @dev Transfers ownership of the reverse BNS record associated with the
     *      calling account.
     * @param owner The address to set as the owner of the reverse record in BNS.
     * @return The BNS node hash of the reverse record.
     */
    function claim(address owner) public returns (bytes32) {
        return claimForAddr(msg.sender, owner, address(defaultResolver));
    }

    /**
     * @dev Transfers ownership of the reverse BNS record associated with the
     *      calling account.
     * @param addr The reverse record to set
     * @param owner The address to set as the owner of the reverse record in BNS.
     * @param resolver The resolver of the reverse node
     * @return The BNS node hash of the reverse record.
     */
    function claimForAddr(address addr, address owner, address resolver) public authorised(addr) returns (bytes32) {
        bytes32 labelHash = sha3HexAddress(addr);
        bytes32 reverseNode = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, labelHash));
        registry.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);
        emit ReverseClaimed(addr, reverseNode);
        return reverseNode;
    }

    /**
     * @dev Transfers ownership of the reverse BNS record associated with the
     *      calling account.
     * @param owner The address to set as the owner of the reverse record in BNS.
     * @param resolver The address of the resolver to set; 0 to leave unchanged.
     * @return The BNS node hash of the reverse record.
     */
    function claimWithResolver(address owner, address resolver) public returns (bytes32) {
        return claimForAddr(msg.sender, owner, resolver);
    }

    /**
     * @dev Sets the `name()` record for the reverse BNS record associated with
     * the calling account. First updates the resolver to the default reverse
     * resolver if necessary.
     * @param name The name to set for this address.
     * @return The BNS node hash of the reverse record.
     */
    function setName(string memory name) public returns (bytes32) {
        return setNameForAddr(msg.sender, msg.sender, address(defaultResolver), name);
    }

    /**
     * @dev Sets the `name()` record for the reverse BNS record associated with
     * the account provided. Updates the resolver to a designated resolver
     * Only callable by controllers and authorised users
     * @param addr The reverse record to set
     * @param owner The owner of the reverse node
     * @param resolver The resolver of the reverse node
     * @param name The name to set for this address.
     * @return The BNS node hash of the reverse record.
     */
    function setNameForAddr(address addr, address owner, address resolver, string memory name)
        public
        override
        returns (bytes32)
    {
        bytes32 node_ = claimForAddr(addr, owner, resolver);
        AbstractNameResolver(resolver).setName(node_, name);
        return node_;
    }

    /**
     * @dev Returns the node hash for a given account's reverse records.
     * @param addr The address to hash
     * @return The BNS node hash.
     */
    function node(address addr) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));
    }

    /**
     * @dev An optimised function to compute the sha3 of the lower-case
     *      hexadecimal representation of an Ethereum address.
     * @param addr The address to hash
     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the
     *         input address.
     */
    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {
        bytes16 lookup = "0123456789abcdef";
        assembly {
            for { let i := 40 } gt(i, 0) {} {
                i := sub(i, 1)
                mstore8(i, byte(and(addr, 0xf), lookup))
                addr := div(addr, 0x10)
                i := sub(i, 1)
                mstore8(i, byte(and(addr, 0xf), lookup))
                addr := div(addr, 0x10)
            }

            ret := keccak256(0, 40)
        }
    }

    function ownsContract(address addr) internal view returns (bool) {
        try Ownable(addr).owner() returns (address owner) {
            return owner == msg.sender;
        } catch {
            return false;
        }
    }
}


================================================
File: src/registrar/interfaces/IPriceOracle.sol
================================================
//SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 <0.9.0;

interface IPriceOracle {
    /// @notice The payment method for registration.
    enum Payment {
        BERA,
        STABLE
    }

    /// @notice The price for a given label.
    struct Price {
        uint256 base;
        uint256 discount;
    }

    /// @notice The price for a given label.
    /// This assumes a default payment method of BERA.
    /// @param label The label to query.
    /// @param expires The expiry of the label.
    /// @param duration The duration of the registration.
    /// @return The price of the label.
    function price(string calldata label, uint256 expires, uint256 duration) external view returns (Price memory);

    /// @notice The price for a given label.
    /// @param label The label to query.
    /// @param expires The expiry of the label.
    /// @param duration The duration of the registration.
    /// @param payment The payment method.
    /// @return The price of the label.
    function price(string calldata label, uint256 expires, uint256 duration, Payment payment)
        external
        view
        returns (Price memory);
}


================================================
File: src/registrar/interfaces/IReservedRegistry.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

interface IReservedRegistry {
    function isReservedName(string memory name) external view returns (bool);
}


================================================
File: src/registrar/interfaces/IReverseRegistrar.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

interface IReverseRegistrar {
    /// @notice Thrown when the registry is invalid.
    error InvalidRegistry();

    function claim(address claimant) external returns (bytes32);

    function setNameForAddr(address addr, address owner, address resolver, string memory name)
        external
        returns (bytes32);
}


================================================
File: src/registrar/types/BaseRegistrar.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

import {BNS} from "src/registry/interfaces/BNS.sol";

import {GRACE_PERIOD, RECLAIM_ID} from "src/utils/Constants.sol";

/// @title Base Registrar
contract BaseRegistrar is ERC721, Ownable {
    using Strings for uint256;

    /// Errors -----------------------------------------------------------

    /// @notice Thrown when the name has expired.
    ///
    /// @param tokenId The id of the token that expired.
    error Expired(uint256 tokenId);

    /// @notice Thrown when called by an unauthorized owner.
    ///
    /// @param tokenId The id that was being called against.
    /// @param sender The unauthorized sender.
    error NotApprovedOwner(uint256 tokenId, address sender);

    /// @notice Thrown when the name is not available for registration.
    ///
    /// @param tokenId The id of the name that is not available.
    error NotAvailable(uint256 tokenId);

    /// @notice Thrown when the queried tokenId does not exist.
    ///
    /// @param tokenId The id of the name that does not exist.
    error NonexistentToken(uint256 tokenId);

    /// @notice Thrown when the name is not registered or in its Grace Period.
    ///
    /// @param tokenId The id of the token that is not registered or in Grace Period.
    error NotRegisteredOrInGrace(uint256 tokenId);

    /// @notice Thrown when msg.sender is not an approved Controller.
    error OnlyController();

    /// @notice Thrown when this contract does not own the `baseNode`.
    error RegistrarNotLive();

    /// Events -----------------------------------------------------------

    /// @notice Emitted when a Controller is added to the approved `controllers` mapping.
    ///
    /// @param controller The address of the approved controller.
    event ControllerAdded(address indexed controller);

    /// @notice Emitted when a Controller is removed from the approved `controllers` mapping.
    ///
    /// @param controller The address of the removed controller.
    event ControllerRemoved(address indexed controller);

    /// @notice Emitted when a name is registered.
    ///
    /// @param id The id of the registered name.
    /// @param owner The owner of the registered name.
    /// @param expires The expiry of the new ownership record.
    event NameRegistered(uint256 indexed id, address indexed owner, uint256 expires);

    /// @notice Emitted when a name is renewed.
    ///
    /// @param id The id of the renewed name.
    /// @param expires The new expiry for the name.
    event NameRenewed(uint256 indexed id, uint256 expires);

    /// @notice Emitted when a name is registered with BNS Records.
    ///
    /// @param id The id of the newly registered name.
    /// @param owner The owner of the registered name.
    /// @param expires The expiry of the new ownership record.
    /// @param resolver The address of the resolver for the name.
    /// @param ttl The time-to-live for the name.
    event NameRegisteredWithRecord(
        uint256 indexed id, address indexed owner, uint256 expires, address resolver, uint64 ttl
    );

    /// @notice Emitted when metadata for a token range is updated.
    ///
    /// @dev Useful for third-party platforms such as NFT marketplaces who can update
    ///     the images and related attributes of the NFTs in a timely fashion.
    ///     To refresh a whole collection, emit `_toTokenId` with `type(uint256).max`
    ///     ERC-4906: https://eip.tools/eip/4906
    ///
    /// @param _fromTokenId The starting range of `tokenId` for which metadata has been updated.
    /// @param _toTokenId The ending range of `tokenId` for which metadata has been updated.
    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);

    /// @notice Emitted when the metadata for the contract collection is updated.
    ///
    /// @dev ERC-7572: https://eips.ethereum.org/EIPS/eip-7572
    event ContractURIUpdated();

    /// Storage ----------------------------------------------------------

    /// @notice The Registry contract.
    BNS public immutable registry;

    /// @notice A map of expiry times to node.
    mapping(bytes32 node => uint256 expiry) public nameExpires;

    /// @notice The namehash of the TLD this registrar owns (eg, .bera).
    bytes32 public immutable baseNode;

    /// @notice The base URI for token metadata.
    string private _tokenURI;

    /// @notice The URI for collection metadata.
    string private _collectionURI;

    /// @notice A map of addresses that are authorised to register and renew names.
    mapping(address controller => bool isApproved) public controllers;

    /// Modifiers --------------------------------------------------------

    /// @notice Decorator for determining if the contract is actively managing registrations for its `baseNode`.
    modifier live() {
        if (registry.owner(baseNode) != address(this)) {
            revert RegistrarNotLive();
        }
        _;
    }

    /// @notice Decorator for restricting methods to only approved Controller callers.
    modifier onlyController() {
        if (!controllers[msg.sender]) revert OnlyController();
        _;
    }

    /// @notice Decorator for determining if a name is available.
    ///
    /// @param id The id being checked for availability.
    modifier onlyAvailable(uint256 id) {
        if (!isAvailable(id)) revert NotAvailable(id);
        _;
    }

    /// @notice Decorator for determining if a name has expired.
    ///
    /// @param id The id being checked for expiry.
    modifier onlyNonExpired(uint256 id) {
        if (nameExpires[bytes32(id)] <= block.timestamp) revert Expired(id);
        _;
    }

    /// Constructor ------------------------------------------------------

    /// @notice BaseRegistrar constructor used to initialize the configuration of the implementation.
    ///
    /// @param registry_ The Registry contract.
    /// @param owner_ The permissioned address initialized as the `owner` in the `Ownable` context.
    /// @param baseNode_ The node that this contract manages registrations for.
    /// @param tokenURI_ The base token URI for NFT metadata.
    /// @param collectionURI_ The URI for the collection's metadata.
    constructor(BNS registry_, address owner_, bytes32 baseNode_, string memory tokenURI_, string memory collectionURI_)
        ERC721("Beranames", unicode"ðŸ»ðŸªª")
        Ownable(owner_)
    {
        _transferOwnership(owner_);
        registry = registry_;
        baseNode = baseNode_;
        _tokenURI = tokenURI_;
        _collectionURI = collectionURI_;
    }

    /// Admin Functions --------------------------------------------------

    /// @notice Authorises a controller, who can register and renew domains.
    /// @dev Emits `ControllerAdded(controller)` after adding the `controller` to the `controllers` mapping.
    /// @param controller The address of the new controller.
    function addController(address controller) external onlyOwner {
        controllers[controller] = true;
        emit ControllerAdded(controller);
    }

    /// @notice Revoke controller permission for an address.
    /// @dev Emits `ControllerRemoved(controller)` after removing the `controller` from the `controllers` mapping.
    /// @param controller The address of the controller to remove.
    function removeController(address controller) external onlyOwner {
        controllers[controller] = false;
        emit ControllerRemoved(controller);
    }

    /// @notice Set the resolver for the node this registrar manages.
    /// @param resolver The address of the new resolver contract.
    function setResolver(address resolver) external onlyOwner {
        registry.setResolver(baseNode, resolver);
    }

    /// @notice Register a name and add details to the record in the Registry.
    /// @param id The token id determined by keccak256(label).
    /// @param owner The address that should own the registration.
    /// @param duration Duration in seconds for the registration.
    /// @param resolver Address of the resolver for the name.
    /// @param ttl Time-to-live for the name.
    function registerWithRecord(uint256 id, address owner, uint256 duration, address resolver, uint64 ttl)
        external
        live
        onlyController
        onlyAvailable(id)
        returns (uint256)
    {
        uint256 expiry = _localRegister(id, owner, duration);
        registry.setSubnodeRecord(baseNode, bytes32(id), owner, resolver, ttl);
        emit NameRegisteredWithRecord(id, owner, expiry, resolver, ttl);
        return expiry;
    }

    /// @notice Gets the owner of the specified token ID.
    /// @dev Names become unowned when their registration expires.
    /// @param tokenId The id of the name to query the owner of.
    /// @return address The address currently marked as the owner of the given token ID.
    function ownerOf(uint256 tokenId) public view override onlyNonExpired(tokenId) returns (address) {
        return super.ownerOf(tokenId);
    }

    /// @notice Returns true if the specified name is available for registration.
    /// @param id The id of the name to check availability of.
    /// @return `true` if the name is available, else `false`.
    function isAvailable(uint256 id) public view returns (bool) {
        // Not available if it's registered here or in its grace period.
        return nameExpires[bytes32(id)] + GRACE_PERIOD < block.timestamp;
    }

    /// @notice Allows holders of names to renew their ownerhsip and extend their expiry.
    /// @param id The id of the name to renew.
    /// @param duration The time that will be added to this name's expiry.
    /// @return The new expiry date.
    function renew(uint256 id, uint256 duration) external live onlyController returns (uint256) {
        uint256 expires = nameExpires[bytes32(id)];
        if (expires + GRACE_PERIOD < block.timestamp) {
            revert NotRegisteredOrInGrace(id);
        }

        expires += duration;
        nameExpires[bytes32(id)] = expires;
        emit NameRenewed(id, expires);
        return expires;
    }

    /// @notice ERC165 compliant signal for interface support.
    /// @param interfaceID the ERC165 iface id being checked for compliance
    /// @return bool Whether this contract supports the provided interfaceID
    function supportsInterface(bytes4 interfaceID) public pure override(ERC721) returns (bool) {
        return interfaceID == type(IERC165).interfaceId || interfaceID == type(IERC721).interfaceId
            || interfaceID == RECLAIM_ID;
    }

    /// ERC721 Implementation --------------------------------------------

    /// @notice Returns the Uniform Resource Identifier (URI) for token `id`.
    /// @dev Reverts if the `tokenId` has not be registered.
    /// @param tokenId The token for which to return the metadata uri.
    /// @return The URI for the specified `tokenId`.
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (_ownerOf(tokenId) == address(0)) revert NonexistentToken(tokenId);

        return bytes(_tokenURI).length > 0 ? string.concat(_tokenURI, tokenId.toString()) : "";
    }

    /// @notice Returns the Uniform Resource Identifier (URI) for the contract.
    /// @dev ERC-7572: https://eips.ethereum.org/EIPS/eip-7572
    function contractURI() public view returns (string memory) {
        return _collectionURI;
    }

    /// @dev Allows the owner to set the the base Uniform Resource Identifier (URI)`.
    ///     Emits the `BatchMetadataUpdate` event for the full range of valid `tokenIds`.
    function setTokenURI(string memory baseURI_) public onlyOwner {
        _tokenURI = baseURI_;
        /// @dev minimum valid tokenId is `1` because uint256(nodehash) will never be called against `nodehash == 0x0`.
        emit BatchMetadataUpdate(1, type(uint256).max);
    }

    /// @dev Allows the owner to set the the contract Uniform Resource Identifier (URI)`.
    ///     Emits the `ContractURIUpdated` event.
    function setContractURI(string memory collectionURI_) public onlyOwner {
        _collectionURI = collectionURI_;
        emit ContractURIUpdated();
    }

    /// @notice transferFrom is overridden to handle the registry update.
    function transferFrom(address from, address to, uint256 tokenId) public override {
        super.transferFrom(from, to, tokenId);
        registry.setSubnodeOwner(baseNode, bytes32(tokenId), to);
    }

    /// Internal Methods -------------------------------------------------

    /// @notice Register a name and possibly update the Registry.
    /// @param id The token id determined by keccak256(label).
    /// @param owner The address that should own the registration.
    /// @param duration Duration in seconds for the registration.
    /// @param updateRegistry Whether to update the Regstiry with the ownership change
    ///
    /// @return The expiry date of the registered name.
    function _register(uint256 id, address owner, uint256 duration, bool updateRegistry)
        internal
        live
        onlyController
        onlyAvailable(id)
        returns (uint256)
    {
        uint256 expiry = _localRegister(id, owner, duration);
        if (updateRegistry) {
            registry.setSubnodeOwner(baseNode, bytes32(id), owner);
        }
        emit NameRegistered(id, owner, expiry);
        return expiry;
    }

    /// @notice Internal handler for local state changes during registrations.
    /// @dev Sets the token's expiry time and then `burn`s and `mint`s a new token.
    /// @param id The token id determined by keccak256(label).
    /// @param owner The address that should own the registration.
    /// @param duration Duration in seconds for the registration.
    ///
    /// @return expiry The expiry date of the registered name.
    function _localRegister(uint256 id, address owner, uint256 duration) internal returns (uint256 expiry) {
        expiry = block.timestamp + duration;
        nameExpires[bytes32(id)] = expiry;
        if (_ownerOf(id) != address(0)) {
            // Name was previously owned, and expired
            _burn(id);
        }
        _mint(owner, id);
    }

    /// @notice Returns whether the given spender can transfer a given token ID.
    /// @param spender address of the spender to query
    /// @param tokenId uint256 ID of the token to be transferred
    /// @return `true` if msg.sender is approved for the given token ID, is an operator of the owner,
    ///         or is the owner of the token, else `false`.
    function _isApprovedOrOwner(address spender, uint256 tokenId)
        internal
        view
        onlyNonExpired(tokenId)
        returns (bool)
    {
        address owner_ = _ownerOf(tokenId);
        return owner_ == spender || _isAuthorized(owner_, spender, tokenId);
    }
}


================================================
File: src/registrar/types/Controllable.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract Controllable is Ownable {
    mapping(address => bool) public controllers;

    event ControllerChanged(address indexed controller, bool enabled);

    modifier onlyController() {
        require(controllers[msg.sender], "Controllable: Caller is not a controller");
        _;
    }

    constructor(address owner_) Ownable(owner_) {}

    function setController(address controller, bool enabled) public onlyOwner {
        controllers[controller] = enabled;
        emit ControllerChanged(controller, enabled);
    }
}


================================================
File: src/registrar/types/PriceOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 <0.9.0;

import {IPriceOracle} from "src/registrar/interfaces/IPriceOracle.sol";
import {IPyth} from "@pythnetwork/pyth-sdk-solidity/IPyth.sol";
import {PythStructs} from "@pythnetwork/pyth-sdk-solidity/PythStructs.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {StringUtils} from "src/utils/StringUtils.sol";
import {console} from "forge-std/console.sol";

contract PriceOracle is IPriceOracle, Ownable {
    using StringUtils for string;

    IPyth pyth;
    bytes32 beraUsdPythPriceFeedId;

    /// @notice The minimum price in wei. If conversion is less than this, revert. Editable by admin
    uint256 minPriceInWei;

    /// @notice Thrown when the price is too low.
    error PriceTooLow();

    /// @notice Thrown when the Pyth contract is invalid.
    error InvalidPyth();

    /// @notice Emitted when the minimum price in wei is set.
    event MinPriceInWeiSet(uint256 minPriceInWei_);

    /// @notice Emitted when the Pyth price feed id is set.
    event BeraUsdPythPriceFeedIdSet(bytes32 beraUsdPythPriceFeedId_);

    /// @notice Emitted when the Pyth contract is set.
    event PythSet(address pyth_);

    constructor(address pyth_, bytes32 beraUsdPythPriceFeedId_) Ownable(msg.sender) {
        if (pyth_ == address(0)) revert InvalidPyth();

        pyth = IPyth(pyth_);
        beraUsdPythPriceFeedId = beraUsdPythPriceFeedId_;
    }

    function setMinPriceInWei(uint256 minPriceInWei_) external onlyOwner {
        minPriceInWei = minPriceInWei_;
        emit MinPriceInWeiSet(minPriceInWei_);
    }

    function setBeraUsdPythPriceFeedId(bytes32 beraUsdPythPriceFeedId_) external onlyOwner {
        beraUsdPythPriceFeedId = beraUsdPythPriceFeedId_;
        emit BeraUsdPythPriceFeedIdSet(beraUsdPythPriceFeedId_);
    }

    function setPyth(address pyth_) external onlyOwner {
        pyth = IPyth(pyth_);
        emit PythSet(pyth_);
    }

    /// @notice Calculates the price for a given label with a default payment method of ETH.
    /// @param label The label to query.
    /// @param expires The expiry of the label.
    /// @param duration The duration of the registration in seconds.
    /// @return The price of the label.
    function price(string calldata label, uint256 expires, uint256 duration) external view returns (Price memory) {
        return price(label, expires, duration, Payment.BERA);
    }

    /// @notice Calculates the price for a given label with a specified payment method.
    /// @param label The label to query.
    /// param expiry The expiry of the label. Not used atm
    /// @param duration The duration of the registration in seconds.
    /// @param payment The payment method.
    /// @return The price of the label.
    function price(string calldata label, uint256, uint256 duration, Payment payment)
        public
        view
        returns (Price memory)
    {
        // Implement your logic to calculate the base and premium price
        (uint256 basePrice, uint256 discount) = calculateBasePrice(label, duration);

        // Adjust the price based on the payment method if necessary
        if (payment == Payment.BERA) {
            basePrice = convertToToken(basePrice);
            discount = convertToToken(discount);
        }

        return Price(basePrice, discount);
    }

    /// @notice Calculates the base price for a given label and duration.
    /// @param label The label to query.
    /// @param duration The duration of the registration.
    /// @return base The base price before discount.
    /// @return discount The discount.
    function calculateBasePrice(string calldata label, uint256 duration)
        internal
        pure
        returns (uint256 base, uint256 discount)
    {
        uint256 nameLength = label.strlen();

        uint256 pricePerYear;
        // notation is $_cents_4zeros => $*10^6
        if (nameLength == 1) {
            pricePerYear = 420_00_0000; // 1 character 420$
        } else if (nameLength == 2) {
            pricePerYear = 269_00_0000; // 2 characters 269$
        } else if (nameLength == 3) {
            pricePerYear = 169_00_0000; // 3 characters 169$
        } else if (nameLength == 4) {
            pricePerYear = 69_00_0000; // 4 characters 69$
        } else {
            pricePerYear = 25_00_0000; // 5+ characters 25$
        }

        uint256 discount_;
        if (duration <= 365 days) {
            discount_ = 0;
        } else if (duration <= 2 * 365 days) {
            discount_ = 5;
        } else if (duration <= 3 * 365 days) {
            discount_ = 15;
        } else if (duration <= 4 * 365 days) {
            discount_ = 30;
        } else {
            discount_ = 40;
        }

        uint256 totalPrice = (pricePerYear * duration) / 365 days;
        uint256 discountAmount = (totalPrice * discount_) / 100;
        return (totalPrice, discountAmount);
    }

    /// @notice Converts a price from a stablecoin equivalent to ETH.
    /// @dev This function can revert with StalePrice
    /// @param price_ The price in stablecoin.
    /// @return The price in BERA.
    function convertToToken(uint256 price_) internal view returns (uint256) {
        PythStructs.Price memory conversionRate = pyth.getPriceNoOlderThan(beraUsdPythPriceFeedId, 30);

        uint256 beraPrice18Decimals =
            (uint256(uint64(conversionRate.price)) * (10 ** 18)) / (10 ** uint8(uint32(-1 * conversionRate.expo)));
        // 6 is the number of decimals in USD prices, so 18-6=12
        uint256 oneDollarInWei = ((10 ** 12) * (10 ** 18)) / beraPrice18Decimals;

        // if the price of 1 dollar is less than the minimum price, revert
        // prevent the price from being too low if price feed is down
        if (oneDollarInWei <= minPriceInWei) revert PriceTooLow();

        return price_ * oneDollarInWei;
    }
}


================================================
File: src/registrar/types/ReservedRegistry.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {IReservedRegistry} from "src/registrar/interfaces/IReservedRegistry.sol";

import {StringUtils} from "src/utils/StringUtils.sol";

contract ReservedRegistry is Ownable, IReservedRegistry {
    using StringUtils for string;

    /// Errors -----------------------------------------------------------

    /// @dev Thrown when a name is already reserved.
    error NameAlreadyReserved(string name);

    /// @dev Thrown when the index is out of bounds.
    error IndexOutOfBounds();

    /// State ------------------------------------------------------------

    mapping(bytes32 => string) private _reservedNames;

    bytes32[] private _reservedNamesList;
    uint256 private _reservedNamesCount;

    /// Constructor ------------------------------------------------------

    constructor(address owner_) Ownable(owner_) {}

    /// Admin Functions  ---------------------------------------------------

    /// @dev Sets a reserved name.
    /// @param name_ The name to set as reserved.
    function setReservedName(string calldata name_) public onlyOwner {
        bytes32 labelHash_ = keccak256(abi.encodePacked(name_));
        if (isReservedName(name_)) revert NameAlreadyReserved(name_);

        _reservedNames[labelHash_] = name_;
        _reservedNamesList.push(labelHash_);
        _reservedNamesCount++;
    }

    /// @dev Removes a reserved name.
    /// @param index_ The index of the reserved name to remove.
    /// @dev After deleting the name, we swap the last element in the array with the one we are deleting to avoid re-indexing.
    function removeReservedName(uint256 index_) public onlyOwner {
        if (index_ >= _reservedNamesCount) revert IndexOutOfBounds();

        bytes32 labelHash_ = _reservedNamesList[index_];
        delete _reservedNames[labelHash_];
        _reservedNamesList[index_] = _reservedNamesList[_reservedNamesCount - 1];
        _reservedNamesList.pop();
        _reservedNamesCount--;
    }

    /// Accessors --------------------------------------------------------

    function reservedNamesCount() public view returns (uint256) {
        return _reservedNamesCount;
    }

    function reservedName(uint256 index_) public view returns (string memory) {
        return _reservedNames[_reservedNamesList[index_]];
    }

    function isReservedName(string calldata name_) public view returns (bool) {
        return _reservedNames[keccak256(abi.encodePacked(name_))].strlen() > 0;
    }
}


================================================
File: src/registrar/types/ReverseClaimer.sol
================================================
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {BNS} from "src/registry/interfaces/BNS.sol";
import {IReverseRegistrar} from "src/registrar/interfaces/IReverseRegistrar.sol";
import {ADDR_REVERSE_NODE} from "src/utils/Constants.sol";

contract ReverseClaimer {
    constructor(BNS bns, address claimant) {
        IReverseRegistrar reverseRegistrar = IReverseRegistrar(bns.owner(ADDR_REVERSE_NODE));
        reverseRegistrar.claim(claimant);
    }
}


================================================
File: src/registrar/types/bArtioPriceOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 <0.9.0;

import {IPriceOracle} from "src/registrar/interfaces/IPriceOracle.sol";

import {StringUtils} from "src/utils/StringUtils.sol";

contract bArtioPriceOracle is IPriceOracle {
    using StringUtils for string;

    /// @notice Calculates the price for a given label with a default payment method of ETH.
    /// @param label The label to query.
    /// @param expires The expiry of the label.
    /// @param duration The duration of the registration in seconds.
    /// @return The price of the label.
    function price(string calldata label, uint256 expires, uint256 duration) external pure returns (Price memory) {
        return price(label, expires, duration, Payment.BERA);
    }

    /// @notice Calculates the price for a given label with a specified payment method.
    /// @param label The label to query.
    /// param expiry The expiry of the label. Not used atm
    /// @param duration The duration of the registration in seconds.
    /// @return The price of the label.
    function price(string calldata label, uint256, uint256 duration, Payment) public pure returns (Price memory) {
        (uint256 basePrice, uint256 discount) = calculateBasePrice(label, duration);

        return Price(basePrice, discount);
    }

    /// @notice Calculates the base price for a given label and duration.
    /// @param label The label to query.
    /// @param duration The duration of the registration.
    /// @return base The base price before discount.
    /// @return discount The discount.
    function calculateBasePrice(string calldata label, uint256 duration)
        internal
        pure
        returns (uint256 base, uint256 discount)
    {
        uint256 nameLength = label.strlen();

        uint256 pricePerYear;
        // notation is $_cents_4zeros => $*10^6
        if (nameLength == 1) {
            pricePerYear = 16; // 1 character 16 BERA
        } else if (nameLength == 2) {
            pricePerYear = 8; // 2 characters 269$
        } else if (nameLength == 3) {
            pricePerYear = 4; // 3 characters 169$
        } else if (nameLength == 4) {
            pricePerYear = 2; // 4 characters 69$
        } else {
            pricePerYear = 1; // 5+ characters 25$
        }
        pricePerYear = pricePerYear * 10 ** 18;

        uint256 discount_;
        if (duration <= 365 days) {
            discount_ = 0;
        } else if (duration <= 2 * 365 days) {
            discount_ = 5;
        } else if (duration <= 3 * 365 days) {
            discount_ = 15;
        } else if (duration <= 4 * 365 days) {
            discount_ = 30;
        } else {
            discount_ = 40;
        }

        uint256 totalPrice = (pricePerYear * duration) / 365 days;
        uint256 discountAmount = (totalPrice * discount_) / 100;
        return (totalPrice, discountAmount);
    }
}


================================================
File: src/registry/Registry.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {BNS} from "src/registry/interfaces/BNS.sol";

/**
 * The BNS registry contract.
 */
contract BeraNamesRegistry is BNS {
    struct Record {
        address owner;
        address resolver;
        uint64 ttl;
    }

    mapping(bytes32 => Record) records;
    mapping(address => mapping(address => bool)) operators;

    /// @notice Thrown when a node is not authorised for a modification.
    /// @param node The node that was not authorised.
    /// @param sender The address that attempted the modification.
    error NotAuthorised(bytes32 node, address sender);

    // Permits modifications only by the owner of the specified node.
    modifier authorised(bytes32 node_) {
        address nodeOwner = records[node_].owner;
        if (nodeOwner != msg.sender && !operators[nodeOwner][msg.sender]) {
            revert NotAuthorised(node_, msg.sender);
        }
        _;
    }

    /**
     * @dev Constructs a new BNS registry.
     */
    constructor() {
        records[0x0].owner = msg.sender;
        emit Transfer(0x0, msg.sender);
    }

    /**
     * @dev Sets the record for a node.
     * @param node_ The node to update.
     * @param owner_ The address of the new owner.
     * @param resolver_ The address of the resolver.
     * @param ttl_ The TTL in seconds.
     */
    function setRecord(bytes32 node_, address owner_, address resolver_, uint64 ttl_) external virtual override {
        setOwner(node_, owner_);
        _setResolverAndTTL(node_, resolver_, ttl_);
    }

    /**
     * @dev Sets the record for a subnode.
     * @param node_ The parent node.
     * @param label_ The hash of the label specifying the subnode.
     * @param owner_ The address of the new owner.
     * @param resolver_ The address of the resolver.
     * @param ttl_ The TTL in seconds.
     */
    function setSubnodeRecord(bytes32 node_, bytes32 label_, address owner_, address resolver_, uint64 ttl_)
        external
        virtual
        override
    {
        bytes32 subnode_ = setSubnodeOwner(node_, label_, owner_);
        _setResolverAndTTL(subnode_, resolver_, ttl_);
    }

    /**
     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.
     * @param node_ The node to transfer ownership of.
     * @param owner_ The address of the new owner.
     */
    function setOwner(bytes32 node_, address owner_) public virtual override authorised(node_) {
        _setOwner(node_, owner_);
        emit Transfer(node_, owner_);
    }

    /**
     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.
     * @param node_ The parent node.
     * @param label_ The hash of the label specifying the subnode.
     * @param owner_ The address of the new owner.
     */
    function setSubnodeOwner(bytes32 node_, bytes32 label_, address owner_)
        public
        virtual
        override
        authorised(node_)
        returns (bytes32)
    {
        bytes32 subnode = keccak256(abi.encodePacked(node_, label_));
        _setOwner(subnode, owner_);
        emit NewOwner(node_, label_, owner_);
        return subnode;
    }

    /**
     * @dev Sets the resolver address for the specified node.
     * @param node_ The node to update.
     * @param resolver_ The address of the resolver.
     */
    function setResolver(bytes32 node_, address resolver_) public virtual override authorised(node_) {
        emit NewResolver(node_, resolver_);
        records[node_].resolver = resolver_;
    }

    /**
     * @dev Sets the TTL for the specified node.
     * @param node_ The node to update.
     * @param ttl_ The TTL in seconds.
     */
    function setTTL(bytes32 node_, uint64 ttl_) public virtual override authorised(node_) {
        emit NewTTL(node_, ttl_);
        records[node_].ttl = ttl_;
    }

    /**
     * @dev Enable or disable approval for a third party ("operator") to manage
     *  all of `msg.sender`'s BNS records. Emits the ApprovalForAll event.
     * @param operator_ Address to add to the set of authorized operators.
     * @param approved_ True if the operator is approved, false to revoke approval.
     */
    function setApprovalForAll(address operator_, bool approved_) external virtual override {
        operators[msg.sender][operator_] = approved_;
        emit ApprovalForAll(msg.sender, operator_, approved_);
    }

    /**
     * @dev Returns the address that owns the specified node.
     * @param node_ The specified node.
     * @return address of the owner.
     */
    function owner(bytes32 node_) public view virtual override returns (address) {
        address addr_ = records[node_].owner;
        if (addr_ == address(this)) {
            return address(0x0);
        }

        return addr_;
    }

    /**
     * @dev Returns the address of the resolver for the specified node.
     * @param node_ The specified node.
     * @return address of the resolver.
     */
    function resolver(bytes32 node_) public view virtual override returns (address) {
        return records[node_].resolver;
    }

    /**
     * @dev Returns the TTL of a node, and any records associated with it.
     * @param node_ The specified node.
     * @return ttl of the node.
     */
    function ttl(bytes32 node_) public view virtual override returns (uint64) {
        return records[node_].ttl;
    }

    /**
     * @dev Returns whether a record has been imported to the registry.
     * @param node_ The specified node.
     * @return Bool if record exists
     */
    function recordExists(bytes32 node_) public view virtual override returns (bool) {
        return records[node_].owner != address(0x0);
    }

    /**
     * @dev Query if an address is an authorized operator for another address.
     * @param owner_ The address that owns the records.
     * @param operator_ The address that acts on behalf of the owner.
     * @return True if `operator_` is an approved operator for `owner_`, false otherwise.
     */
    function isApprovedForAll(address owner_, address operator_) external view virtual override returns (bool) {
        return operators[owner_][operator_];
    }

    function _setOwner(bytes32 node_, address owner_) internal virtual {
        records[node_].owner = owner_;
    }

    function _setResolverAndTTL(bytes32 node_, address resolver_, uint64 ttl_) internal {
        if (resolver_ != records[node_].resolver) {
            records[node_].resolver = resolver_;
            emit NewResolver(node_, resolver_);
        }

        if (ttl_ != records[node_].ttl) {
            records[node_].ttl = ttl_;
            emit NewTTL(node_, ttl_);
        }
    }
}


================================================
File: src/registry/interfaces/BNS.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface BNS {
    // Logged when the owner of a node assigns a new owner to a subnode.
    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);

    // Logged when the owner of a node transfers ownership to a new account.
    event Transfer(bytes32 indexed node, address owner);

    // Logged when the resolver for a node changes.
    event NewResolver(bytes32 indexed node, address resolver);

    // Logged when the TTL of a node changes
    event NewTTL(bytes32 indexed node, uint64 ttl);

    // Logged when an operator is added or removed.
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;

    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;

    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);

    function setResolver(bytes32 node, address resolver) external;

    function setOwner(bytes32 node, address owner) external;

    function setTTL(bytes32 node, uint64 ttl) external;

    function setApprovalForAll(address operator, bool approved) external;

    function owner(bytes32 node) external view returns (address);

    function resolver(bytes32 node) external view returns (address);

    function ttl(bytes32 node) external view returns (uint64);

    function recordExists(bytes32 node) external view returns (bool);

    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


================================================
File: src/resolver/Resolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

// Admin Controller
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

// Bera Name Service
import {BNS} from "src/registry/interfaces/BNS.sol";

// Interfaces
import {IExtendedResolver} from "src/resolver/interfaces/IExtendedResolver.sol";
import {IReverseRegistrar} from "src/registrar/interfaces/IReverseRegistrar.sol";

// Resolver Profiles
import {ABIResolver} from "src/resolver/profiles/ABIResolver.sol";
import {AddrResolver} from "src/resolver/profiles/AddrResolver.sol";
import {ContentHashResolver} from "src/resolver/profiles/ContentHashResolver.sol";
// import {DNSResolver} from "src/resolver/profiles/DNSResolver.sol";
import {ExtendedResolver} from "src/resolver/profiles/ExtendedResolver.sol";
import {InterfaceResolver} from "src/resolver/profiles/InterfaceResolver.sol";
import {Multicallable} from "src/resolver/types/Multicallable.sol";
import {NameResolver} from "src/resolver/profiles/NameResolver.sol";
import {PubkeyResolver} from "src/resolver/profiles/PubkeyResolver.sol";
import {TextResolver} from "src/resolver/profiles/TextResolver.sol";

/// @title BeraResolver
contract BeraDefaultResolver is
    // Accessability Controller
    Multicallable,
    // Resolvers
    ABIResolver,
    AddrResolver,
    ContentHashResolver,
    // DNSResolver,
    InterfaceResolver,
    NameResolver,
    PubkeyResolver,
    TextResolver,
    ExtendedResolver,
    // Admin Controller
    Ownable
{
    /// Errors -----------------------------------------------------------

    /// @notice Thown when msg.sender tries to set itself as an operator/delegate.
    error CantSetSelf();

    /// @notice Thown when the registrar controller is not set.
    error InvalidRegistrarController();

    /// @notice Thown when the reverse registrar is not set.
    error InvalidReverseRegistrar();

    /// @notice Thown when the caller is not the owner of the node.
    error NotOwner();

    /// Storage ----------------------------------------------------------

    /// @notice The BNS registry.
    BNS public immutable bns;

    /// @notice The trusted registrar controller contract.
    address public registrarController;

    /// @notice The reverse registrar contract.
    address public reverseRegistrar;

    /// @notice A mapping of account operators: can control owner's nodes.
    mapping(address owner => mapping(address operator => bool isApproved)) private _operatorApprovals;

    /// @notice A mapping node operators: can control a specific node.
    mapping(address owner => mapping(bytes32 node => mapping(address delegate => bool isApproved))) private
        _tokenApprovals;

    /// Events -----------------------------------------------------------

    /// @notice Emitted when an operator is added or removed.
    ///
    /// @param owner The address of the owner of names.
    /// @param operator The address of the approved operator for the `owner`.
    /// @param approved Whether the `operator` is approved or not.
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /// @notice Emitted when a delegate is approved or an approval is revoked.
    ///
    /// @param owner The address of the owner of the name.
    /// @param node The namehash of the name.
    /// @param delegate The address of the operator for the specified `node`.
    /// @param approved Whether the `delegate` is approved for the specified `node`.
    event Approved(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved);

    /// @notice Emitted when the owner of this contract updates the Registrar Controller addrress.
    ///
    /// @param newRegistrarController The address of the new RegistrarController contract.
    event RegistrarControllerUpdated(address indexed newRegistrarController);

    /// @notice Emitted when the owner of this contract updates the Reverse Registrar address.
    ///
    /// @param newReverseRegistrar The address of the new ReverseRegistrar contract.
    event ReverseRegistrarUpdated(address indexed newReverseRegistrar);

    /// Constructor ------------------------------------------------------

    /// @notice L2 Resolver constructor used to establish the necessary contract configuration.
    ///
    /// @param bns_ The Registry contract.
    /// @param registrarController_ The address of the RegistrarController contract.
    /// @param reverseRegistrar_ The address of the ReverseRegistrar contract.
    /// @param owner_  The permissioned address initialized as the `owner` in the `Ownable` context.
    constructor(BNS bns_, address registrarController_, address reverseRegistrar_, address owner_) Ownable(owner_) {
        // Set state
        bns = bns_;

        if (registrarController_ == address(0)) revert InvalidRegistrarController();
        if (reverseRegistrar_ == address(0)) revert InvalidReverseRegistrar();

        registrarController = registrarController_;
        reverseRegistrar = reverseRegistrar_;

        // Initialize reverse registrar
        IReverseRegistrar(reverseRegistrar_).claim(owner_);
    }

    /// Authorisation Functions -----------------------------------------

    /// @dev See {IERC1155-setApprovalForAll}.
    function setApprovalForAll(address operator, bool approved) external {
        if (msg.sender == operator) revert CantSetSelf();

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /// @dev See {IERC1155-isApprovedForAll}.
    function isApprovedForAll(address account, address operator) public view returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /// @notice Modify the permissions for a specified `delegate` for the specified `node`.
    ///
    /// @dev This method only sets the approval status for msg.sender's nodes.
    ///
    /// @param node The namehash `node` whose permissions are being updated.
    /// @param delegate The address of the `delegate`
    /// @param approved Whether the `delegate` has approval to modify records for `msg.sender`'s `node`.
    function approve(bytes32 node, address delegate, bool approved) external {
        if (msg.sender == delegate) revert CantSetSelf();
        if (msg.sender != bns.owner(node)) revert NotOwner();

        _tokenApprovals[msg.sender][node][delegate] = approved;
        emit Approved(msg.sender, node, delegate, approved);
    }

    /// @notice Check to see if the `delegate` has been approved by the `owner` for the `node`.
    ///
    /// @param owner The address of the name owner.
    /// @param node The namehash `node` whose permissions are being checked.
    /// @param delegate The address of the `delegate` whose permissions are being checked.
    ///
    /// @return `true` if `delegate` is approved to modify `msg.sender`'s `node`, else `false`.
    function isApprovedFor(address owner, bytes32 node, address delegate) public view returns (bool) {
        return _tokenApprovals[owner][node][delegate];
    }

    /// @notice Check to see whether `msg.sender` is authorized to modify records for the specified `node`.
    ///
    /// @dev Override for `ResolverBase:isAuthorised()`. Used in the context of each inherited resolver "profile".
    ///     Validates that `msg.sender` is one of:
    ///     1. The stored registrarController (for setting records upon registration)
    ///     2  The stored reverseRegistrar (for setting reverse records)
    ///     3. The owner of the node in the Registry
    ///     4. An approved operator for owner
    ///     5. An approved delegate for owner of the specified `node`
    ///
    /// @param node The namehashed `node` being authorized.
    ///
    /// @return `true` if `msg.sender` is authorized to modify records for the specified `node`, else `false`.
    function isAuthorised(bytes32 node) internal view override returns (bool) {
        if (msg.sender == registrarController || msg.sender == reverseRegistrar) {
            return true;
        }
        address owner = bns.owner(node);
        return owner == msg.sender || isApprovedForAll(owner, msg.sender) || isApprovedFor(owner, node, msg.sender);
    }

    /// ERC165 Interface Support -----------------------------------------

    /// @notice ERC165 compliant signal for interface support.
    /// @param interfaceID the ERC165 iface id being checked for compliance
    /// @return bool Whether this contract supports the provided interfaceID
    function supportsInterface(bytes4 interfaceID)
        public
        view
        override(
            Multicallable,
            ABIResolver,
            AddrResolver,
            ContentHashResolver,
            // DNSResolver,
            InterfaceResolver,
            NameResolver,
            PubkeyResolver,
            TextResolver
        )
        returns (bool)
    {
        return (interfaceID == type(IExtendedResolver).interfaceId || super.supportsInterface(interfaceID));
    }

    /// Admin Functions --------------------------------------------------

    /// @notice Allows the `owner` to set the registrar controller contract address.
    ///
    /// @dev Emits `RegistrarControllerUpdated` after setting the `registrarController` address.
    ///
    /// @param registrarController_ The address of the new RegistrarController contract.
    function setRegistrarController(address registrarController_) external onlyOwner {
        if (registrarController_ == address(0)) revert InvalidRegistrarController();

        registrarController = registrarController_;
        emit RegistrarControllerUpdated(registrarController_);
    }

    /// @notice Allows the `owner` to set the reverse registrar contract address.
    ///
    /// @dev Emits `ReverseRegistrarUpdated` after setting the `reverseRegistrar` address.
    ///
    /// @param reverseRegistrar_ The address of the new ReverseRegistrar contract.
    function setReverseRegistrar(address reverseRegistrar_) external onlyOwner {
        if (reverseRegistrar_ == address(0)) revert InvalidReverseRegistrar();

        reverseRegistrar = reverseRegistrar_;
        emit ReverseRegistrarUpdated(reverseRegistrar_);
    }
}


================================================
File: src/resolver/UniversalResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 <0.9.0;

import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";

import {BeraDefaultResolver} from "src/resolver/Resolver.sol";
import {LowLevelCallUtils} from "src/resolver/libraries/LowLevelCallUtils.sol";
import {IExtendedResolver} from "src/resolver/interfaces/IExtendedResolver.sol";
import {INameResolver} from "src/resolver/interfaces/INameResolver.sol";
import {IAddrResolver} from "src/resolver/interfaces/IAddrResolver.sol";

import {BNS} from "src/registry/interfaces/BNS.sol";
import {NameEncoder} from "src/resolver/libraries/NameEncoder.sol";
import {BytesUtils} from "src/resolver/libraries/BytesUtils.sol";
import {HexUtils} from "src/resolver/libraries/HexUtils.sol";

/// @notice Thrown when the offchain lookup fails.
error OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData);

/// @notice Thrown when the resolver is not found.
error ResolverNotFound();

/// @notice Thrown when the resolver wildcard is not supported.
error ResolverWildcardNotSupported();

/// @notice Thrown when the registry is invalid.
error InvalidRegistry();

/// @notice Thrown when the array lengths do not match.
error ArrayLengthsMustMatch();

/// @notice Thrown when the encrypted label length is invalid.
error InvalidEncryptedLabelLength();

struct MulticallData {
    bytes name;
    bytes[] data;
    string[] gateways;
    bytes4 callbackFunction;
    bool isWildcard;
    address resolver;
    bytes metaData;
    bool[] failures;
}

struct OffchainLookupCallData {
    address sender;
    string[] urls;
    bytes callData;
}

struct OffchainLookupExtraData {
    bytes4 callbackFunction;
    bytes data;
}

interface BatchGateway {
    function query(OffchainLookupCallData[] memory data)
        external
        returns (bool[] memory failures, bytes[] memory responses);
}

/**
 * The Universal Resolver is a contract that handles the work of resolving a name entirely onchain,
 * making it possible to make a single smart contract call to resolve an BNS name.
 */
contract UniversalResolver is ERC165, Ownable {
    using Address for address;
    using NameEncoder for string;
    using BytesUtils for bytes;
    using HexUtils for bytes;

    string[] public batchGatewayURLs;
    BNS public immutable registry;

    constructor(address _registry, string[] memory _urls) Ownable(msg.sender) {
        if (_registry == address(0)) revert InvalidRegistry();

        registry = BNS(_registry);
        batchGatewayURLs = _urls;
    }

    function setGatewayURLs(string[] memory _urls) public onlyOwner {
        batchGatewayURLs = _urls;
    }

    /**
     * @dev Performs BNS name resolution for the supplied name and resolution data.
     * @param name The name to resolve, in normalised and DNS-encoded form.
     * @param data The resolution data, as specified in ENSIP-10.
     * @return The result of resolving the name.
     */
    function resolve(bytes calldata name, bytes memory data) external view returns (bytes memory, address) {
        return _resolveSingle(name, data, batchGatewayURLs, this.resolveSingleCallback.selector, "");
    }

    function resolve(bytes calldata name, bytes[] memory data) external view returns (bytes[] memory, address) {
        return resolve(name, data, batchGatewayURLs);
    }

    function resolve(bytes calldata name, bytes memory data, string[] memory gateways)
        external
        view
        returns (bytes memory, address)
    {
        return _resolveSingle(name, data, gateways, this.resolveSingleCallback.selector, "");
    }

    function resolve(bytes calldata name, bytes[] memory data, string[] memory gateways)
        public
        view
        returns (bytes[] memory, address)
    {
        return _resolve(name, data, gateways, this.resolveCallback.selector, "");
    }

    function _resolveSingle(
        bytes calldata name,
        bytes memory data,
        string[] memory gateways,
        bytes4 callbackFunction,
        bytes memory metaData
    ) public view returns (bytes memory, address) {
        bytes[] memory dataArr = new bytes[](1);
        dataArr[0] = data;
        (bytes[] memory results, address resolver) = _resolve(name, dataArr, gateways, callbackFunction, metaData);
        return (results[0], resolver);
    }

    function _resolve(
        bytes calldata name,
        bytes[] memory data,
        string[] memory gateways,
        bytes4 callbackFunction,
        bytes memory metaData
    ) internal view returns (bytes[] memory results, address resolverAddress) {
        (BeraDefaultResolver resolver,, uint256 finalOffset) = findResolver(name);
        resolverAddress = address(resolver);
        if (resolverAddress == address(0)) {
            revert ResolverNotFound();
        }

        bool isWildcard = finalOffset != 0;

        results = _multicall(
            MulticallData(
                name, data, gateways, callbackFunction, isWildcard, resolverAddress, metaData, new bool[](data.length)
            )
        );
    }

    /**
     * @dev Performs BNS name reverse resolution for the supplied reverse name. Called by Viem when doing getEnsName()
     * @param reverseName The reverse name to resolve, in normalised and DNS-encoded form. e.g. b6E040C9ECAaE172a89bD561c5F73e1C48d28cd9.addr.reverse
     * @return The resolved name, the resolved address, the reverse resolver address, and the resolver address.
     */
    function reverse(bytes calldata reverseName) external view returns (string memory, address, address, address) {
        return reverse(reverseName, batchGatewayURLs);
    }

    /**
     * @dev Performs BNS name reverse resolution for the supplied reverse name.
     * @param reverseName The reverse name to resolve, in normalised and DNS-encoded form. e.g. b6E040C9ECAaE172a89bD561c5F73e1C48d28cd9.addr.reverse
     * @return The resolved name, the resolved address, the reverse resolver address, and the resolver address.
     */
    function reverse(bytes calldata reverseName, string[] memory gateways)
        public
        view
        returns (string memory, address, address, address)
    {
        bytes memory encodedCall = abi.encodeCall(INameResolver.name, reverseName.namehash(0));
        (bytes memory resolvedReverseData, address reverseResolverAddress) =
            _resolveSingle(reverseName, encodedCall, gateways, this.reverseCallback.selector, "");

        return getForwardDataFromReverse(resolvedReverseData, reverseResolverAddress, gateways);
    }

    function getForwardDataFromReverse(
        bytes memory resolvedReverseData,
        address reverseResolverAddress,
        string[] memory gateways
    ) internal view returns (string memory, address, address, address) {
        string memory resolvedName = abi.decode(resolvedReverseData, (string));

        (bytes memory encodedName, bytes32 namehash) = resolvedName.dnsEncodeName();

        bytes memory encodedCall = abi.encodeCall(IAddrResolver.addr, namehash);
        bytes memory metaData = abi.encode(resolvedName, reverseResolverAddress);
        (bytes memory resolvedData, address resolverAddress) =
            this._resolveSingle(encodedName, encodedCall, gateways, this.reverseCallback.selector, metaData);

        address resolvedAddress = abi.decode(resolvedData, (address));

        return (resolvedName, resolvedAddress, reverseResolverAddress, resolverAddress);
    }

    function resolveSingleCallback(bytes calldata response, bytes calldata extraData)
        external
        view
        returns (bytes memory, address)
    {
        (bytes[] memory results, address resolver,,) =
            _resolveCallback(response, extraData, this.resolveSingleCallback.selector);
        return (results[0], resolver);
    }

    function resolveCallback(bytes calldata response, bytes calldata extraData)
        external
        view
        returns (bytes[] memory, address)
    {
        (bytes[] memory results, address resolver,,) =
            _resolveCallback(response, extraData, this.resolveCallback.selector);
        return (results, resolver);
    }

    function reverseCallback(bytes calldata response, bytes calldata extraData)
        external
        view
        returns (string memory, address, address, address)
    {
        (bytes[] memory resolvedData, address resolverAddress, string[] memory gateways, bytes memory metaData) =
            _resolveCallback(response, extraData, this.reverseCallback.selector);

        if (metaData.length > 0) {
            (string memory resolvedName, address reverseResolverAddress) = abi.decode(metaData, (string, address));
            address resolvedAddress = abi.decode(resolvedData[0], (address));
            return (resolvedName, resolvedAddress, reverseResolverAddress, resolverAddress);
        }

        return getForwardDataFromReverse(resolvedData[0], resolverAddress, gateways);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IExtendedResolver).interfaceId || super.supportsInterface(interfaceId);
    }

    function _resolveCallback(bytes calldata response, bytes calldata extraData, bytes4 callbackFunction)
        internal
        view
        returns (bytes[] memory, address, string[] memory, bytes memory)
    {
        MulticallData memory multicallData;
        multicallData.callbackFunction = callbackFunction;
        (bool[] memory failures, bytes[] memory responses) = abi.decode(response, (bool[], bytes[]));
        OffchainLookupExtraData[] memory extraDatas;
        (multicallData.isWildcard, multicallData.resolver, multicallData.gateways, multicallData.metaData, extraDatas) =
            abi.decode(extraData, (bool, address, string[], bytes, OffchainLookupExtraData[]));
        require(responses.length <= extraDatas.length);
        multicallData.data = new bytes[](extraDatas.length);
        multicallData.failures = new bool[](extraDatas.length);
        uint256 offchainCount = 0;
        for (uint256 i = 0; i < extraDatas.length; i++) {
            if (extraDatas[i].callbackFunction == bytes4(0)) {
                // This call did not require an offchain lookup; use the previous input data.
                multicallData.data[i] = extraDatas[i].data;
            } else {
                if (failures[offchainCount]) {
                    multicallData.failures[i] = true;
                    multicallData.data[i] = responses[offchainCount];
                } else {
                    multicallData.data[i] = abi.encodeWithSelector(
                        extraDatas[i].callbackFunction, responses[offchainCount], extraDatas[i].data
                    );
                }
                offchainCount = offchainCount + 1;
            }
        }

        return (_multicall(multicallData), multicallData.resolver, multicallData.gateways, multicallData.metaData);
    }

    /**
     * @dev Makes a call to `target` with `data`. If the call reverts with an `OffchainLookup` error, wraps
     *      the error with the data necessary to continue the request where it left off.
     * @param target The address to call.
     * @param data The data to call `target` with.
     * @return offchain Whether the call reverted with an `OffchainLookup` error.
     * @return returnData If `target` did not revert, contains the return data from the call to `target`. Otherwise, contains a `OffchainLookupCallData` struct.
     * @return extraData If `target` did not revert, is empty. Otherwise, contains a `OffchainLookupExtraData` struct.
     * @return result Whether the call succeeded.
     */
    function callWithOffchainLookupPropagation(address target, bytes memory data)
        internal
        view
        returns (bool offchain, bytes memory returnData, OffchainLookupExtraData memory extraData, bool result)
    {
        result = LowLevelCallUtils.functionStaticCall(address(target), data);
        uint256 size = LowLevelCallUtils.returnDataSize();

        if (result) {
            return (false, LowLevelCallUtils.readReturnData(0, size), extraData, true);
        }

        // Failure
        if (size >= 4) {
            bytes memory errorId = LowLevelCallUtils.readReturnData(0, 4);
            // Offchain lookup. Decode the revert message and create our own that nests it.
            bytes memory revertData = LowLevelCallUtils.readReturnData(4, size - 4);
            if (bytes4(errorId) == OffchainLookup.selector) {
                (
                    address wrappedSender,
                    string[] memory wrappedUrls,
                    bytes memory wrappedCallData,
                    bytes4 wrappedCallbackFunction,
                    bytes memory wrappedExtraData
                ) = abi.decode(revertData, (address, string[], bytes, bytes4, bytes));
                if (wrappedSender == target) {
                    returnData = abi.encode(OffchainLookupCallData(wrappedSender, wrappedUrls, wrappedCallData));
                    extraData = OffchainLookupExtraData(wrappedCallbackFunction, wrappedExtraData);
                    return (true, returnData, extraData, false);
                }
            } else {
                returnData = bytes.concat(errorId, revertData);
                return (false, returnData, extraData, false);
            }
        }
    }

    /**
     * @dev Finds a resolver by recursively querying the registry, starting at the longest name and progressively
     *      removing labels until it finds a result.
     * @param name The name to resolve, in DNS-encoded and normalised form.
     * @return resolver The Resolver responsible for this name.
     * @return namehash The namehash of the full name.
     * @return finalOffset The offset of the first label with a resolver.
     */
    function findResolver(bytes calldata name) public view returns (BeraDefaultResolver, bytes32, uint256) {
        (address resolver, bytes32 namehash, uint256 finalOffset) = findResolver(name, 0);
        return (BeraDefaultResolver(resolver), namehash, finalOffset);
    }

    function findResolver(bytes calldata name, uint256 offset) internal view returns (address, bytes32, uint256) {
        // Add bounds checking for offset
        if (offset >= name.length) {
            return (address(0), bytes32(0), offset);
        }

        uint256 labelLength = uint256(uint8(name[offset]));
        if (labelLength == 0) {
            return (address(0), bytes32(0), offset);
        }

        // Add bounds checking for the full label range
        if (offset + labelLength + 1 > name.length) {
            return (address(0), bytes32(0), offset);
        }

        uint256 nextLabel = offset + labelLength + 1;
        bytes32 labelHash;
        if (
            // 0x5b == '['
            // 0x5d == ']'
            labelLength == 66 && name[offset + 1] == 0x5b && name[nextLabel - 1] == 0x5d
        ) {
            // Validate the hex string is exactly 64 characters
            bytes memory hexString = bytes(name[offset + 2:nextLabel - 1]);
            if (hexString.length != 64) revert InvalidEncryptedLabelLength();

            // Validate all characters are valid hex
            for (uint256 i = 0; i < 64; i++) {
                bytes1 char = hexString[i];
                if (
                    !(char >= 0x30 && char <= 0x39) // 0-9
                        && !(char >= 0x41 && char <= 0x46) // A-F
                        && !(char >= 0x61 && char <= 0x66) // a-f
                ) {
                    revert("Invalid hex character in encrypted label");
                }
            }

            // Convert validated hex string to bytes32
            (labelHash,) = hexString.hexStringToBytes32(0, 64);
        } else {
            labelHash = keccak256(name[offset + 1:nextLabel]);
        }
        (address parentresolver, bytes32 parentnode, uint256 parentoffset) = findResolver(name, nextLabel);
        bytes32 node = keccak256(abi.encodePacked(parentnode, labelHash));
        address resolver = registry.resolver(node);
        if (resolver != address(0)) {
            return (resolver, node, offset);
        }
        return (parentresolver, node, parentoffset);
    }

    function _hasExtendedResolver(address resolver) internal view returns (bool) {
        try BeraDefaultResolver(resolver).supportsInterface{gas: 50_000}(type(IExtendedResolver).interfaceId) returns (
            bool supported
        ) {
            return supported;
        } catch {
            return false;
        }
    }

    function _multicall(MulticallData memory multicallData) internal view returns (bytes[] memory results) {
        uint256 length = multicallData.data.length;
        if (length != multicallData.failures.length) revert ArrayLengthsMustMatch();

        uint256 offchainCount = 0;
        OffchainLookupCallData[] memory callDatas = new OffchainLookupCallData[](length);
        OffchainLookupExtraData[] memory extraDatas = new OffchainLookupExtraData[](length);
        results = new bytes[](length);
        bool isCallback = multicallData.name.length == 0;
        bool hasExtendedResolver = _hasExtendedResolver(multicallData.resolver);

        if (multicallData.isWildcard && !hasExtendedResolver) {
            revert ResolverWildcardNotSupported();
        }

        for (uint256 i = 0; i < length; i++) {
            bytes memory item = multicallData.data[i];
            bool failure = multicallData.failures[i];
            if (failure) {
                results[i] = item;
                continue;
            }
            if (!isCallback && hasExtendedResolver) {
                item = abi.encodeCall(IExtendedResolver.resolve, (multicallData.name, item));
            }
            (bool offchain, bytes memory returnData, OffchainLookupExtraData memory extraData, bool success) =
                callWithOffchainLookupPropagation(multicallData.resolver, item);

            if (offchain) {
                callDatas[offchainCount] = abi.decode(returnData, (OffchainLookupCallData));
                extraDatas[i] = extraData;
                offchainCount += 1;
                continue;
            }

            if (success && hasExtendedResolver) {
                // if this is a successful resolve() call, unwrap the result
                returnData = abi.decode(returnData, (bytes));
            }
            results[i] = returnData;
            extraDatas[i].data = multicallData.data[i];
        }

        if (offchainCount == 0) {
            return results;
        }

        // Trim callDatas if offchain data exists
        assembly {
            mstore(callDatas, offchainCount)
        }

        revert OffchainLookup(
            address(this),
            multicallData.gateways,
            abi.encodeWithSelector(BatchGateway.query.selector, callDatas),
            multicallData.callbackFunction,
            abi.encode(
                multicallData.isWildcard,
                multicallData.resolver,
                multicallData.gateways,
                multicallData.metaData,
                extraDatas
            )
        );
    }
}


================================================
File: src/resolver/interfaces/IABIResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface IABIResolver {
    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);

    /**
     * Returns the ABI associated with an ENS node.
     * Defined in EIP205.
     * @param node The ENS node to query
     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.
     * @return contentType The content type of the return value
     * @return data The ABI data
     */
    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);
}


================================================
File: src/resolver/interfaces/IAddrResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

/**
 * Interface for the legacy (ETH-only) addr function.
 */
interface IAddrResolver {
    event AddrChanged(bytes32 indexed node, address a);

    /**
     * Returns the address associated with an BNS node.
     * @param node The BNS node to query.
     * @return The associated address.
     */
    function addr(bytes32 node) external view returns (address payable);
}


================================================
File: src/resolver/interfaces/IAddressResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

/**
 * Interface for the new (multicoin) addr function.
 */
interface IAddressResolver {
    event AddressChanged(bytes32 indexed node, uint256 coinType, bytes newAddress);

    function addr(bytes32 node, uint256 coinType) external view returns (bytes memory);
}


================================================
File: src/resolver/interfaces/IContentHashResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface IContentHashResolver {
    event ContenthashChanged(bytes32 indexed node, bytes hash);

    /**
     * Returns the contenthash associated with an BNS node.
     * @param node The BNS node to query.
     * @return The associated contenthash.
     */
    function contenthash(bytes32 node) external view returns (bytes memory);
}


================================================
File: src/resolver/interfaces/IExtendedResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IExtendedResolver {
    function resolve(bytes memory name, bytes memory data) external view returns (bytes memory);
}


================================================
File: src/resolver/interfaces/IInterfaceResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface IInterfaceResolver {
    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);

    /**
     * Returns the address of a contract that implements the specified interface for this name.
     * If an implementer has not been set for this interfaceID and name, the resolver will query
     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that
     * contract implements EIP165 and returns `true` for the specified interfaceID, its address
     * will be returned.
     * @param node The BNS node to query.
     * @param interfaceID The EIP 165 interface ID to check for.
     * @return The address that implements this interface, or 0 if the interface is unsupported.
     */
    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);
}


================================================
File: src/resolver/interfaces/IMulticallable.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IMulticallable {
    function multicall(bytes[] calldata data) external returns (bytes[] memory results);

    function multicallWithNodeCheck(bytes32, bytes[] calldata data) external returns (bytes[] memory results);
}


================================================
File: src/resolver/interfaces/INameResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface INameResolver {
    event NameChanged(bytes32 indexed node, string name);

    /**
     * Returns the name associated with an BNS node, for reverse records.
     * Defined in EIP181.
     * @param node The BNS node to query.
     * @return The associated name.
     */
    function name(bytes32 node) external view returns (string memory);
}

abstract contract AbstractNameResolver {
    function setName(bytes32 node, string memory name) public virtual;
}


================================================
File: src/resolver/interfaces/IPubkeyResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface IPubkeyResolver {
    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);

    /**
     * Returns the SECP256k1 public key associated with an ENS node.
     * Defined in EIP 619.
     * @param node The ENS node to query
     * @return x The X coordinate of the curve point for the public key.
     * @return y The Y coordinate of the curve point for the public key.
     */
    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);
}


================================================
File: src/resolver/interfaces/ITextResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface ITextResolver {
    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value);

    /**
     * Returns the text data associated with an BNS node and key.
     * @param node The BNS node to query.
     * @param key The text data key to query.
     * @return The associated text data.
     */
    function text(bytes32 node, string calldata key) external view returns (string memory);
}


================================================
File: src/resolver/interfaces/IVersionableResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

interface IVersionableResolver {
    event VersionChanged(bytes32 indexed node, uint64 newVersion);

    function recordVersions(bytes32 node) external view returns (uint64);
}


================================================
File: src/resolver/libraries/BytesUtils.sol
================================================
//SPDX-License-Identifier: MIT
pragma solidity ~0.8.17;

library BytesUtils {
    /*
     * @dev Returns the keccak-256 hash of a byte range.
     * @param self The byte string to hash.
     * @param offset The position to start hashing at.
     * @param len The number of bytes to hash.
     * @return The hash of the byte range.
     */
    function keccak(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }

    /**
     * @dev Returns the ENS namehash of a DNS-encoded name.
     * @param self The DNS-encoded name to hash.
     * @param offset The offset at which to start hashing.
     * @return The namehash of the name.
     */
    function namehash(bytes memory self, uint256 offset) internal pure returns (bytes32) {
        // First count the number of labels
        uint256 labelCount = 0;
        uint256 countOffset = offset;

        while (countOffset < self.length) {
            bytes32 labelhash;
            uint256 newOffset;
            (labelhash, newOffset) = readLabel(self, countOffset);

            if (labelhash == bytes32(0)) {
                break;
            }

            labelCount++;
            countOffset = newOffset;
        }

        // Then find all label hashes
        bytes32[] memory labels = new bytes32[](labelCount);
        uint256 currentOffset = offset;
        uint256 index = 0;

        while (currentOffset < self.length) {
            bytes32 labelhash;
            uint256 newOffset;
            (labelhash, newOffset) = readLabel(self, currentOffset);

            if (labelhash == bytes32(0)) {
                require(currentOffset == self.length - 1, "namehash: Junk at end of name");
                break;
            }

            labels[index] = labelhash;
            index++;
            currentOffset = newOffset;
        }

        // Finally compute namehash from right to left
        bytes32 node = bytes32(0);
        while (labelCount > 0) {
            labelCount--;
            node = keccak256(abi.encodePacked(node, labels[labelCount]));
        }

        return node;
    }

    /**
     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.
     * @param self The byte string to read a label from.
     * @param idx The index to read a label at.
     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.
     * @return newIdx The index of the start of the next label.
     */
    function readLabel(bytes memory self, uint256 idx) internal pure returns (bytes32 labelhash, uint256 newIdx) {
        require(idx < self.length, "readLabel: Index out of bounds");
        uint256 len = uint256(uint8(self[idx]));
        if (len > 0) {
            labelhash = keccak(self, idx + 1, len);
        } else {
            labelhash = bytes32(0);
        }
        newIdx = idx + len + 1;
    }
}


================================================
File: src/resolver/libraries/HexUtils.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

library HexUtils {
    /**
     * @dev Attempts to parse bytes32 from a hex string
     * @param str The string to parse
     * @param idx The offset to start parsing at
     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.
     */
    function hexStringToBytes32(bytes memory str, uint256 idx, uint256 lastIdx)
        internal
        pure
        returns (bytes32 r, bool valid)
    {
        if ((lastIdx - idx) % 2 != 0) return (r, false);
        if (idx >= lastIdx || lastIdx > str.length) return (bytes32(0), false);

        valid = true;
        assembly {
            // check that the index to read to is not past the end of the string
            if gt(lastIdx, mload(str)) { revert(0, 0) }

            function getHex(c) -> ascii {
                // chars 48-57: 0-9
                if and(gt(c, 47), lt(c, 58)) {
                    ascii := sub(c, 48)
                    leave
                }
                // chars 65-70: A-F
                if and(gt(c, 64), lt(c, 71)) {
                    ascii := add(sub(c, 65), 10)
                    leave
                }
                // chars 97-102: a-f
                if and(gt(c, 96), lt(c, 103)) {
                    ascii := add(sub(c, 97), 10)
                    leave
                }
                // invalid char
                ascii := 0xff
            }

            let ptr := add(str, 32)
            for { let i := idx } lt(i, lastIdx) { i := add(i, 2) } {
                let byte1 := getHex(byte(0, mload(add(ptr, i))))
                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))
                // if either byte is invalid, set invalid and break loop
                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {
                    valid := false
                    break
                }
                let combined := or(shl(4, byte1), byte2)
                r := or(shl(8, r), combined)
            }
        }
    }

    /**
     * @dev Attempts to parse an address from a hex string
     * @param str The string to parse
     * @param idx The offset to start parsing at
     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.
     */
    function hexToAddress(bytes memory str, uint256 idx, uint256 lastIdx) internal pure returns (address, bool) {
        if (lastIdx - idx != 40) return (address(0x0), false);

        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);
        return (address(uint160(uint256(r))), valid);
    }
}


================================================
File: src/resolver/libraries/LowLevelCallUtils.sol
================================================
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

import {Address} from "@openzeppelin/contracts/utils/Address.sol";

library LowLevelCallUtils {
    using Address for address;

    /**
     * @dev Makes a static call to the specified `target` with `data`. Return data can be fetched with
     *      `returnDataSize` and `readReturnData`.
     * @param target The address to staticcall.
     * @param data The data to pass to the call.
     * @return success True if the call succeeded, or false if it reverts.
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bool success) {
        assembly {
            // Check if the target address has code
            if iszero(extcodesize(target)) { revert(0, 0) }
            // Perform the static call
            success := staticcall(gas(), target, add(data, 32), mload(data), 0, 0)
        }
    }

    /**
     * @dev Returns the size of the return data of the most recent external call.
     */
    function returnDataSize() internal pure returns (uint256 len) {
        assembly {
            len := returndatasize()
        }
    }

    /**
     * @dev Reads return data from the most recent external call.
     * @param offset Offset into the return data.
     * @param length Number of bytes to return.
     * @return data The copied return data
     * @dev Reverts if offset + length exceeds returndatasize
     */
    function readReturnData(uint256 offset, uint256 length) internal pure returns (bytes memory data) {
        data = new bytes(length);
        assembly {
            // Validate that offset + length <= returndatasize()
            if gt(add(offset, length), returndatasize()) { revert(0, 0) }
            returndatacopy(add(data, 32), offset, length)
        }
    }

    /**
     * @dev Reverts with the return data from the most recent external call.
     */
    function propagateRevert() internal pure {
        assembly {
            returndatacopy(0, 0, returndatasize())
            revert(0, returndatasize())
        }
    }
}


================================================
File: src/resolver/libraries/NameEncoder.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {BytesUtils} from "src/resolver/libraries/BytesUtils.sol";

library NameEncoder {
    using BytesUtils for bytes;

    function dnsEncodeName(string memory name) internal pure returns (bytes memory dnsName, bytes32 node) {
        uint8 labelLength = 0;
        bytes memory bytesName = bytes(name);
        uint256 length = bytesName.length;
        dnsName = new bytes(length + 2);
        node = 0;
        if (length == 0) {
            dnsName[0] = 0;
            return (dnsName, node);
        }

        // use unchecked to save gas since we check for an underflow
        // and we check for the length before the loop
        unchecked {
            for (uint256 i = length - 1; i >= 0; i--) {
                if (bytesName[i] == ".") {
                    dnsName[i + 1] = bytes1(labelLength);
                    node = keccak256(abi.encodePacked(node, bytesName.keccak(i + 1, labelLength)));
                    labelLength = 0;
                } else {
                    labelLength += 1;
                    dnsName[i + 1] = bytesName[i];
                }
                if (i == 0) {
                    break;
                }
            }
        }

        node = keccak256(abi.encodePacked(node, bytesName.keccak(0, labelLength)));

        dnsName[0] = bytes1(labelLength);
        return (dnsName, node);
    }
}


================================================
File: src/resolver/profiles/ABIResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import {IABIResolver} from "src/resolver/interfaces/IABIResolver.sol";

abstract contract ABIResolver is IABIResolver, ResolverBase {
    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;

    /**
     * Sets the ABI associated with an BNS node.
     * Nodes may have one ABI of each content type. To remove an ABI, set it to
     * the empty string.
     * @param node The node to update.
     * @param contentType The content type of the ABI
     * @param data The ABI data.
     */
    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external virtual authorised(node) {
        // Content types must be powers of 2
        require(((contentType - 1) & contentType) == 0);

        versionable_abis[recordVersions[node]][node][contentType] = data;
        emit ABIChanged(node, contentType);
    }

    /**
     * Returns the ABI associated with an BNS node.
     * Defined in EIP205.
     * @param node The BNS node to query
     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.
     * @return contentType The content type of the return value
     * @return data The ABI data
     */
    function ABI(bytes32 node, uint256 contentTypes) external view virtual override returns (uint256, bytes memory) {
        mapping(uint256 => bytes) storage abiset = versionable_abis[recordVersions[node]][node];

        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {
            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {
                return (contentType, abiset[contentType]);
            }
        }

        return (0, bytes(""));
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IABIResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/profiles/AddrResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import "src/resolver/interfaces/IAddrResolver.sol";
import "src/resolver/interfaces/IAddressResolver.sol";

abstract contract AddrResolver is IAddrResolver, IAddressResolver, ResolverBase {
    uint256 private constant COIN_TYPE_ETH = 60;

    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;

    /**
     * Sets the address associated with an BNS node.
     * May only be called by the owner of that node in the BNS registry.
     * @param node The node to update.
     * @param a The address to set.
     */
    function setAddr(bytes32 node, address a) external virtual authorised(node) {
        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));
    }

    /**
     * Returns the address associated with an BNS node.
     * @param node The BNS node to query.
     * @return The associated address.
     */
    function addr(bytes32 node) public view virtual override returns (address payable) {
        bytes memory a = addr(node, COIN_TYPE_ETH);
        if (a.length == 0) {
            return payable(0);
        }
        return bytesToAddress(a);
    }

    function setAddr(bytes32 node, uint256 coinType, bytes memory a) public virtual authorised(node) {
        emit AddressChanged(node, coinType, a);
        if (coinType == COIN_TYPE_ETH) {
            emit AddrChanged(node, bytesToAddress(a));
        }
        versionable_addresses[recordVersions[node]][node][coinType] = a;
    }

    function addr(bytes32 node, uint256 coinType) public view virtual override returns (bytes memory) {
        return versionable_addresses[recordVersions[node]][node][coinType];
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IAddrResolver).interfaceId || interfaceID == type(IAddressResolver).interfaceId
            || super.supportsInterface(interfaceID);
    }

    function bytesToAddress(bytes memory b) internal pure returns (address payable a) {
        require(b.length == 20);
        assembly {
            a := div(mload(add(b, 32)), exp(256, 12))
        }
    }

    function addressToBytes(address a) internal pure returns (bytes memory b) {
        b = new bytes(20);
        assembly {
            mstore(add(b, 32), mul(a, exp(256, 12)))
        }
    }
}


================================================
File: src/resolver/profiles/ContentHashResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import "src/resolver/interfaces/IContentHashResolver.sol";

abstract contract ContentHashResolver is IContentHashResolver, ResolverBase {
    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;

    /**
     * Sets the contenthash associated with an BNS node.
     * May only be called by the owner of that node in the BNS registry.
     * @param node The node to update.
     * @param hash The contenthash to set
     */
    function setContenthash(bytes32 node, bytes calldata hash) external virtual authorised(node) {
        versionable_hashes[recordVersions[node]][node] = hash;
        emit ContenthashChanged(node, hash);
    }

    /**
     * Returns the contenthash associated with an BNS node.
     * @param node The BNS node to query.
     * @return The associated contenthash.
     */
    function contenthash(bytes32 node) external view virtual override returns (bytes memory) {
        return versionable_hashes[recordVersions[node]][node];
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/profiles/ExtendedResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract ExtendedResolver {
    function resolve(bytes memory, /* name */ bytes memory data) external view returns (bytes memory) {
        (bool success, bytes memory result) = address(this).staticcall(data);
        if (success) {
            return result;
        } else {
            // Revert with the reason provided by the call
            assembly {
                revert(add(result, 0x20), mload(result))
            }
        }
    }
}


================================================
File: src/resolver/profiles/InterfaceResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import {AddrResolver} from "src/resolver/profiles/AddrResolver.sol";
import {IInterfaceResolver} from "src/resolver/interfaces/IInterfaceResolver.sol";

abstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {
    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;

    /**
     * Sets an interface associated with a name.
     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.
     * @param node The node to update.
     * @param interfaceID The EIP 165 interface ID.
     * @param implementer The address of a contract that implements this interface for this node.
     */
    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external virtual authorised(node) {
        versionable_interfaces[recordVersions[node]][node][interfaceID] = implementer;
        emit InterfaceChanged(node, interfaceID, implementer);
    }

    /**
     * Returns the address of a contract that implements the specified interface for this name.
     * If an implementer has not been set for this interfaceID and name, the resolver will query
     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that
     * contract implements EIP165 and returns `true` for the specified interfaceID, its address
     * will be returned.
     * @param node The BNS node to query.
     * @param interfaceID The EIP 165 interface ID to check for.
     * @return The address that implements this interface, or 0 if the interface is unsupported.
     */
    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view virtual override returns (address) {
        address implementer = versionable_interfaces[recordVersions[node]][node][interfaceID];
        if (implementer != address(0)) {
            return implementer;
        }

        address a = addr(node);
        if (a == address(0)) {
            return address(0);
        }

        (bool success, bytes memory returnData) =
            a.staticcall(abi.encodeWithSignature("supportsInterface(bytes4)", type(IERC165).interfaceId));
        if (!success || returnData.length < 32 || returnData[31] == 0) {
            // EIP 165 not supported by target
            return address(0);
        }

        (success, returnData) = a.staticcall(abi.encodeWithSignature("supportsInterface(bytes4)", interfaceID));
        if (!success || returnData.length < 32 || returnData[31] == 0) {
            // Specified interface not supported by target
            return address(0);
        }

        return a;
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IInterfaceResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/profiles/NameResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import "src/resolver/interfaces/INameResolver.sol";

abstract contract NameResolver is INameResolver, ResolverBase {
    mapping(uint64 => mapping(bytes32 => string)) versionable_names;

    /**
     * Sets the name associated with an BNS node, for reverse records.
     * May only be called by the owner of that node in the BNS registry.
     * @param node The node to update.
     */
    function setName(bytes32 node, string calldata newName) external virtual authorised(node) {
        versionable_names[recordVersions[node]][node] = newName;
        emit NameChanged(node, newName);
    }

    /**
     * Returns the name associated with an BNS node, for reverse records.
     * Defined in EIP181.
     * @param node The BNS node to query.
     * @return The associated name.
     */
    function name(bytes32 node) external view virtual override returns (string memory) {
        return versionable_names[recordVersions[node]][node];
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/profiles/PubkeyResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import "src/resolver/interfaces/IPubkeyResolver.sol";

abstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {
    struct PublicKey {
        bytes32 x;
        bytes32 y;
    }

    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;

    /**
     * Sets the SECP256k1 public key associated with an BNS node.
     * @param node The BNS node to query
     * @param x the X coordinate of the curve point for the public key.
     * @param y the Y coordinate of the curve point for the public key.
     */
    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external virtual authorised(node) {
        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);
        emit PubkeyChanged(node, x, y);
    }

    /**
     * Returns the SECP256k1 public key associated with an BNS node.
     * Defined in EIP 619.
     * @param node The BNS node to query
     * @return x The X coordinate of the curve point for the public key.
     * @return y The Y coordinate of the curve point for the public key.
     */
    function pubkey(bytes32 node) external view virtual override returns (bytes32 x, bytes32 y) {
        uint64 currentRecordVersion = recordVersions[node];
        return (versionable_pubkeys[currentRecordVersion][node].x, versionable_pubkeys[currentRecordVersion][node].y);
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IPubkeyResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/profiles/TextResolver.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ResolverBase} from "src/resolver/types/ResolverBase.sol";
import "src/resolver/interfaces/ITextResolver.sol";

abstract contract TextResolver is ITextResolver, ResolverBase {
    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;

    /**
     * Sets the text data associated with an BNS node and key.
     * May only be called by the owner of that node in the BNS registry.
     * @param node The node to update.
     * @param key The key to set.
     * @param value The text data value to set.
     */
    function setText(bytes32 node, string calldata key, string calldata value) external virtual authorised(node) {
        versionable_texts[recordVersions[node]][node][key] = value;
        emit TextChanged(node, key, key, value);
    }

    /**
     * Returns the text data associated with an BNS node and key.
     * @param node The BNS node to query.
     * @param key The text data key to query.
     * @return The associated text data.
     */
    function text(bytes32 node, string calldata key) external view virtual override returns (string memory) {
        return versionable_texts[recordVersions[node]][node][key];
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/types/Multicallable.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/utils/introspection/ERC165.sol";

// Internal imports
import "src/resolver/interfaces/IMulticallable.sol";

abstract contract Multicallable is IMulticallable, ERC165 {
    function _multicall(bytes32 nodehash, bytes[] calldata data) internal returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint256 i = 0; i < data.length; i++) {
            if (nodehash != bytes32(0)) {
                bytes32 txNamehash = bytes32(data[i][4:36]);
                require(txNamehash == nodehash, "multicall: All records must have a matching namehash");
            }

            (bool success, bytes memory result) = address(this).delegatecall(data[i]);
            if (!success) {
                if (result.length > 0) {
                    assembly {
                        let revertDataSize := mload(result)
                        revert(add(result, 32), revertDataSize)
                    }
                } else {
                    revert("Multicall delegatecall failed without a reason");
                }
            }

            results[i] = result;
        }
        return results;
    }

    // This function provides an extra security check when called
    // from priviledged contracts (such as EthRegistrarController)
    // that can set records on behalf of the node owners
    function multicallWithNodeCheck(bytes32 nodehash, bytes[] calldata data)
        external
        returns (bytes[] memory results)
    {
        return _multicall(nodehash, data);
    }

    function multicall(bytes[] calldata data) public override returns (bytes[] memory results) {
        return _multicall(bytes32(0), data);
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/resolver/types/ResolverBase.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import {IVersionableResolver} from "src/resolver/interfaces/IVersionableResolver.sol";

abstract contract ResolverBase is ERC165, IVersionableResolver {
    mapping(bytes32 => uint64) public recordVersions;

    function isAuthorised(bytes32 node) internal view virtual returns (bool);

    modifier authorised(bytes32 node) {
        require(isAuthorised(node), "Unauthorized");
        _;
    }

    /**
     * Increments the record version associated with an BNS node.
     * May only be called by the owner of that node in the BNS registry.
     * @param node The node to update.
     */
    function clearRecords(bytes32 node) public virtual authorised(node) {
        recordVersions[node]++;
        emit VersionChanged(node, recordVersions[node]);
    }

    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == type(IVersionableResolver).interfaceId || super.supportsInterface(interfaceID);
    }
}


================================================
File: src/utils/Constants.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

// @param BERA_NODE The node hash of "bera"
bytes32 constant BERA_NODE = 0xcac7291742cc038df280cfdc67517aa5d83fe6f4716c336481273a83a877997b;

// @param REVERSE_NODE The node hash of "reverse"
bytes32 constant REVERSE_NODE = 0xa097f6721ce401e757d1223a763fef49b8b5f90bb18567ddb86fd205dff71d34;

// @param ADDR_REVERSE_NODE The node hash of "addr.reverse"
bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;

// @param GRACE_PERIOD the grace period for expired names
uint256 constant GRACE_PERIOD = 30 days;

// @param RECLAIM_ID InterfaceId for the Reclaim interface
bytes4 constant RECLAIM_ID = bytes4(keccak256("reclaim(uint256,address)"));

uint64 constant DEFAULT_TTL = 3600;


================================================
File: src/utils/StringUtils.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library StringUtils {
    error InvalidUTF8Byte();

    function utf8Length(string memory s) internal pure returns (uint256) {
        return bytes(s).length;
    }

    /**
     * @dev Returns the length of a given string, accurately counting characters including complex emojis.
     * @param s The string to measure the length of.
     * @return The length of the input string.
     */
    function strlen(string memory s) internal pure returns (uint256) {
        bytes memory strBytes = bytes(s);
        uint256 len = 0;
        uint256 i = 0;
        uint256 strLen = strBytes.length;

        while (i < strLen) {
            uint256 charLen = _charLength(strBytes, i);
            uint256 nextI = i + charLen;

            // Include any combining marks or modifiers immediately following the base character
            while (nextI < strLen && _isCombiningMarkOrModifier(strBytes, nextI)) {
                nextI += _charLength(strBytes, nextI);
            }

            // Handle sequences involving ZWJs by looping until no more ZWJs are found
            while (nextI < strLen && _isZeroWidthJoiner(strBytes, nextI)) {
                // Move past the ZWJ
                nextI += _charLength(strBytes, nextI);

                // Include the next character after ZWJ
                if (nextI < strLen) {
                    uint256 nextCharLen = _charLength(strBytes, nextI);
                    nextI += nextCharLen;

                    // Include any combining marks or modifiers following the character
                    while (nextI < strLen && _isCombiningMarkOrModifier(strBytes, nextI)) {
                        nextI += _charLength(strBytes, nextI);
                    }
                } else {
                    break; // No character after ZWJ
                }
            }

            // Handle regional indicators (used in flags) - always count as pairs
            if (_isRegionalIndicator(strBytes, i) && nextI < strLen && _isRegionalIndicator(strBytes, nextI)) {
                nextI += _charLength(strBytes, nextI);
            }

            // Increment length for each complete character sequence
            len++;
            i = nextI;
        }

        return len;
    }

    // Determines the length of a UTF-8 encoded character in bytes with validation
    function _charLength(bytes memory strBytes, uint256 index) private pure returns (uint256) {
        uint8 b = uint8(strBytes[index]);

        if (b < 0x80) {
            return 1; // 1-byte character (ASCII)
        } else if (b < 0xE0 && index + 1 < strBytes.length && uint8(strBytes[index + 1]) & 0xC0 == 0x80) {
            return 2; // 2-byte character
        } else if (
            b < 0xF0 && index + 2 < strBytes.length && uint8(strBytes[index + 1]) & 0xC0 == 0x80
                && uint8(strBytes[index + 2]) & 0xC0 == 0x80
        ) {
            return 3; // 3-byte character
        } else if (
            b < 0xF8 && index + 3 < strBytes.length && uint8(strBytes[index + 1]) & 0xC0 == 0x80
                && uint8(strBytes[index + 2]) & 0xC0 == 0x80 && uint8(strBytes[index + 3]) & 0xC0 == 0x80
        ) {
            return 4; // 4-byte character (including emojis)
        } else {
            revert InvalidUTF8Byte();
        }
    }

    // Checks if the sequence starting at index is a Zero-Width Joiner (ZWJ)
    function _isZeroWidthJoiner(bytes memory strBytes, uint256 index) private pure returns (bool) {
        return (
            strBytes[index] == 0xE2 && index + 2 < strBytes.length && strBytes[index + 1] == 0x80
                && strBytes[index + 2] == 0x8D
        );
    }

    // Checks if the character at index is a combining mark or modifier
    function _isCombiningMarkOrModifier(bytes memory strBytes, uint256 index) private pure returns (bool) {
        uint8 b = uint8(strBytes[index]);

        // Combining marks are in the range starting with 0xCC or 0xCD
        if (b == 0xCC || b == 0xCD) {
            return true;
        }

        // Emoji modifiers and variation selectors
        if (b == 0xE2 && index + 2 < strBytes.length) {
            uint8 b1 = uint8(strBytes[index + 1]);
            uint8 b2 = uint8(strBytes[index + 2]);
            // Check for variation selectors (e.g., U+FE0F)
            if (b1 == 0x80 && (b2 == 0x8F || b2 == 0x8E)) {
                return true;
            }
        }

        // Handle emojis with skin tone, gender modifiers, etc.
        if (b == 0xF0 && index + 3 < strBytes.length) {
            uint8 b1 = uint8(strBytes[index + 1]);
            uint8 b2 = uint8(strBytes[index + 2]);
            uint8 b3 = uint8(strBytes[index + 3]);
            // Check for specific sequences that are known modifiers
            if (
                (b1 == 0x9F && b2 == 0x8F && (b3 >= 0xBB && b3 <= 0xBF)) // Skin tone modifiers
                    || (b1 == 0x9F && b2 == 0xA4 && b3 == 0xB0)
            ) {
                // Gender modifiers
                return true;
            }
        }

        // Check for Variation Selector-16 (U+FE0F)
        if (b == 0xEF && index + 2 < strBytes.length) {
            uint8 b1 = uint8(strBytes[index + 1]);
            uint8 b2 = uint8(strBytes[index + 2]);
            if (b1 == 0xB8 && b2 == 0x8F) {
                return true;
            }
        }

        // Check for Combining Enclosing Keycap (U+20E3)
        if (b == 0xE2 && index + 2 < strBytes.length) {
            uint8 b1 = uint8(strBytes[index + 1]);
            uint8 b2 = uint8(strBytes[index + 2]);
            if (b1 == 0x83 && b2 == 0xA3) {
                return true;
            }
        }

        // Checks if the character at index is a Tag Indicator (used in special flag sequences)
        if (
            b == 0xF3 && index + 2 < strBytes.length && strBytes[index + 1] == 0xA0 && strBytes[index + 2] >= 0x80
                && strBytes[index + 2] <= 0x9F
        ) {
            return true;
        }

        return false;
    }

    // Checks if the character at index is a Regional Indicator Symbol (used for flag emojis)
    function _isRegionalIndicator(bytes memory strBytes, uint256 index) private pure returns (bool) {
        return (
            strBytes[index] == 0xF0 && index + 3 < strBytes.length && strBytes[index + 1] == 0x9F
                && strBytes[index + 2] == 0x87
        );
    }
}


